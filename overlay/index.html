<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AegisAV Agent Thought Overlay</title>
  <link rel="icon" type="image/svg+xml" href="/aegis_logo.svg">
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500;600&family=Orbitron:wght@400;500;600;700&display=swap');

    :root {
      --font-sans: "Inter", "SF Pro Display", "Segoe UI", sans-serif;
      --font-mono: "JetBrains Mono", "Roboto Mono", monospace;
      --font-tactical: "Orbitron", "Inter", sans-serif;
      --bg-deep: #050508;
      --bg-onyx: #0a0a0f;
      --card-glass: rgba(15, 15, 20, 0.9);
      --border-glass: rgba(45, 50, 60, 0.8);
      --border-tactical: rgba(0, 212, 255, 0.3);
      --text-primary: #E8E8EC;
      --text-muted: #5A5A68;
      --accent-cyber: #00d4ff;
      --accent-security: #00ff88;
      --accent-alert: #ff3344;
      --accent-warning: #ffaa00;
      --accent-purple: #8b5cf6;
      --accent-blue: #3b82f6;
      --glass-blur: blur(8px);
      --sidebar-width: 300px;
      --corner-cut: 8px;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: var(--bg-deep);
      background-image:
        linear-gradient(rgba(0, 212, 255, 0.015) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 212, 255, 0.015) 1px, transparent 1px);
      background-size: 50px 50px;
      overflow: hidden;
      font-family: var(--font-sans);
      width: 100vw;
      height: 100vh;
      display: flex;
    }

    body.transparent {
      background: transparent;
    }

    /* ========== LEFT SIDEBAR (TACTICAL) ========== */
    .sidebar {
      width: var(--sidebar-width);
      height: 100vh;
      background: var(--card-glass);
      backdrop-filter: var(--glass-blur);
      border-right: 2px solid var(--border-tactical);
      display: flex;
      flex-direction: column;
      overflow: hidden;
      z-index: 100;
      flex-shrink: 0;
      position: relative;
    }

    .sidebar::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 3px;
      background: linear-gradient(90deg, var(--accent-cyber), transparent);
    }

    .sidebar-header {
      padding: 14px 16px;
      border-bottom: 1px solid var(--border-glass);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: rgba(0, 0, 0, 0.3);
    }

    .sidebar-title {
      font-size: 0.85rem;
      font-weight: 600;
      font-family: var(--font-tactical);
      color: var(--accent-cyber);
      text-transform: uppercase;
      letter-spacing: 0.15em;
      text-shadow: 0 0 20px rgba(0, 212, 255, 0.5);
    }

    .sidebar-title::before {
      content: "// ";
      opacity: 0.5;
    }

    .connection-status {
      padding: 4px 10px;
      border-radius: 2px;
      clip-path: polygon(0 0, calc(100% - 4px) 0, 100% 4px, 100% 100%, 4px 100%, 0 calc(100% - 4px));
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .connection-status.connected {
      background: rgba(16, 185, 129, 0.2);
      color: var(--accent-security);
      border: 1px solid rgba(16, 185, 129, 0.4);
    }

    .connection-status.disconnected {
      background: rgba(239, 68, 68, 0.2);
      color: var(--accent-alert);
      border: 1px solid rgba(239, 68, 68, 0.4);
    }

    .connection-status.connecting {
      background: rgba(245, 158, 11, 0.2);
      color: var(--accent-warning);
      border: 1px solid rgba(245, 158, 11, 0.4);
    }

    .sidebar-content {
      flex: 1;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 1px;
      background: var(--border-glass);
    }

    .sidebar-section {
      background: var(--card-glass);
      padding: 14px 16px;
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
      cursor: pointer;
      padding-bottom: 8px;
      border-bottom: 1px solid var(--border-glass);
    }

    .section-title {
      font-size: 0.7rem;
      font-weight: 500;
      font-family: var(--font-tactical);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .section-title::before {
      content: "[";
      color: var(--accent-cyber);
      margin-right: 4px;
      opacity: 0.5;
    }

    .section-title::after {
      content: "]";
      color: var(--accent-cyber);
      margin-left: 4px;
      opacity: 0.5;
    }

    .section-toggle {
      background: none;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      font-size: 1rem;
      padding: 2px 6px;
      transition: color 0.2s;
    }

    .section-toggle:hover {
      color: var(--text-primary);
    }

    .section-content {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .section-content.collapsed {
      display: none;
    }

    /* Form elements */
    select {
      width: 100%;
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(9, 9, 11, 0.9);
      color: var(--text-primary);
      font-size: 0.85rem;
      font-family: var(--font-mono);
    }

    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      padding: 8px 12px;
      border-radius: 8px;
      font-size: 0.8rem;
      font-weight: 600;
      cursor: pointer;
      border: 1px solid rgba(6, 182, 212, 0.35);
      background: rgba(6, 182, 212, 0.08);
      color: var(--text-primary);
      transition: all 0.15s ease;
    }

    .btn.primary {
      background: linear-gradient(135deg, var(--accent-cyber), #0088cc);
      border: none;
      color: #000;
    }

    .btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(6, 182, 212, 0.25);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .btn-row {
      display: flex;
      gap: 8px;
    }

    .btn-row .btn {
      flex: 1;
    }

    .status-text {
      font-size: 0.8rem;
      color: rgba(250, 250, 250, 0.7);
    }

    .link-btn {
      width: 100%;
      text-decoration: none;
      text-align: center;
    }

    /* Camera section */
    .camera-view {
      position: relative;
      width: 100%;
      aspect-ratio: 16/9;
      background: #000;
      border-radius: 8px;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .camera-view img {
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .camera-placeholder {
      color: var(--text-muted);
      font-size: 0.8rem;
      text-align: center;
    }

    .camera-placeholder-icon {
      font-size: 1.5rem;
      margin-bottom: 6px;
      opacity: 0.5;
    }

    /* Multi-drone camera selector */
    .drone-camera-tabs {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
      margin-bottom: 8px;
    }

    .drone-camera-tab {
      padding: 5px 10px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(9, 9, 11, 0.6);
      color: var(--text-muted);
      font-size: 0.7rem;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.15s;
    }

    .drone-camera-tab.active {
      background: rgba(6, 182, 212, 0.2);
      border-color: var(--accent-cyber);
      color: var(--accent-cyber);
    }

    .drone-camera-tab:hover:not(.active) {
      background: rgba(255, 255, 255, 0.1);
      color: var(--text-primary);
    }

    .drone-camera-tab.streaming {
      border-color: rgba(16, 185, 129, 0.5);
    }

    .drone-camera-tab .stream-dot {
      display: inline-block;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: var(--accent-security);
      margin-right: 4px;
      animation: pulse-dot 1.5s ease-in-out infinite;
    }

    @keyframes pulse-dot {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .camera-thumbnails {
      display: flex;
      gap: 6px;
      margin-top: 8px;
      overflow-x: auto;
      padding-bottom: 4px;
    }

    .camera-thumbnail {
      flex-shrink: 0;
      width: 70px;
      height: 40px;
      border-radius: 4px;
      overflow: hidden;
      cursor: pointer;
      border: 2px solid transparent;
      transition: border-color 0.15s;
      background: #000;
      position: relative;
    }

    .camera-thumbnail.selected {
      border-color: var(--accent-cyber);
    }

    .camera-thumbnail:hover:not(.selected) {
      border-color: rgba(255, 255, 255, 0.3);
    }

    .camera-thumbnail img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .camera-thumbnail .thumb-label {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.7);
      color: var(--text-primary);
      font-size: 0.55rem;
      padding: 2px 4px;
      text-align: center;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .camera-thumbnail .thumb-placeholder {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-muted);
      font-size: 0.6rem;
      background: rgba(39, 39, 42, 0.5);
    }

    .camera-overlay {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 6px 10px;
      background: linear-gradient(transparent, rgba(0,0,0,0.8));
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      font-size: 0.7rem;
    }

    .camera-fps {
      position: absolute;
      top: 6px;
      right: 6px;
      font-family: var(--font-mono);
      font-size: 0.65rem;
      color: var(--text-muted);
      padding: 2px 6px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 4px;
    }

    /* Base Station section */
    .base-station-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }

    .base-stat {
      background: rgba(9, 9, 11, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 6px;
      padding: 8px 10px;
    }

    .base-stat-label {
      font-size: 0.65rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 4px;
    }

    .base-stat-value {
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .status-dot.online {
      background: var(--accent-security);
      box-shadow: 0 0 6px var(--accent-security);
    }

    .status-dot.offline {
      background: var(--accent-alert);
    }

    .status-dot.warning {
      background: var(--accent-warning);
    }

    .signal-bars {
      display: flex;
      align-items: flex-end;
      gap: 2px;
      height: 12px;
    }

    .signal-bars .bar {
      width: 3px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 1px;
    }

    .signal-bars .bar:nth-child(1) { height: 4px; }
    .signal-bars .bar:nth-child(2) { height: 6px; }
    .signal-bars .bar:nth-child(3) { height: 9px; }
    .signal-bars .bar:nth-child(4) { height: 12px; }

    .signal-bars .bar.active {
      background: var(--accent-security);
    }

    /* Log section */
    .log-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 180px;
      overflow-y: auto;
    }

    .log-entry {
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.06);
      background: rgba(9, 9, 11, 0.6);
      font-size: 0.75rem;
    }

    .log-entry .meta {
      display: flex;
      justify-content: space-between;
      font-size: 0.65rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-muted);
      margin-bottom: 4px;
    }

    .log-entry.info .level { color: var(--accent-cyber); }
    .log-entry.success .level { color: var(--accent-security); }
    .log-entry.warning .level { color: var(--accent-warning); }
    .log-entry.error .level { color: var(--accent-alert); }

    .log-entry .message {
      color: rgba(250, 250, 250, 0.85);
      line-height: 1.3;
    }

    .log-empty {
      font-size: 0.75rem;
      color: var(--text-muted);
      padding: 4px 0;
    }

    /* ========== MAIN SCENE AREA ========== */
    .scene-container {
      flex: 1;
      height: 100vh;
      position: relative;
      background: var(--bg-deep);
      background-image:
        radial-gradient(circle at 30% 30%, rgba(6, 182, 212, 0.04), transparent 50%),
        radial-gradient(circle at 70% 70%, rgba(16, 185, 129, 0.03), transparent 50%);
      overflow: hidden;
    }

    .scene-svg {
      width: 100%;
      height: 100%;
    }

    /* Isometric grid */
    .iso-grid line {
      stroke: rgba(255, 255, 255, 0.04);
      stroke-width: 1;
    }

    .iso-grid .major {
      stroke: rgba(255, 255, 255, 0.08);
    }

    /* Map cube preview */
    .map-cube-line {
      stroke: rgba(59, 130, 246, 0.8);
      stroke-width: 1.4;
      fill: none;
    }

    .map-cube-face {
      fill: rgba(59, 130, 246, 0.08);
      stroke: rgba(59, 130, 246, 0.4);
      stroke-width: 1;
    }

    .map-cube-point {
      fill: rgba(59, 130, 246, 0.9);
      stroke: rgba(59, 130, 246, 0.4);
      stroke-width: 0.5;
    }

    .map-cube-label {
      fill: var(--accent-blue);
      font-size: 10px;
      font-weight: 600;
      text-anchor: middle;
      font-family: var(--font-mono);
    }

    /* Ground plane */
    .ground-plane {
      fill: rgba(6, 182, 212, 0.02);
      stroke: rgba(6, 182, 212, 0.15);
      stroke-width: 2;
    }

    /* Dock */
    .dock-marker {
      cursor: pointer;
    }

    .dock-base {
      fill: rgba(16, 185, 129, 0.3);
      stroke: var(--accent-security);
      stroke-width: 2;
    }

    .dock-pad {
      fill: rgba(16, 185, 129, 0.15);
      stroke: var(--accent-security);
      stroke-width: 1;
      stroke-dasharray: 4 2;
    }

    .dock-label {
      fill: var(--accent-security);
      font-size: 11px;
      font-weight: 600;
      text-anchor: middle;
      font-family: var(--font-mono);
    }

    /* Assets */
    .asset-group {
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .asset-group:hover {
      transform: scale(1.05);
    }

    .asset-base {
      stroke-width: 1.5;
      transition: all 0.3s ease;
    }

    .asset-base.solar {
      fill: rgba(59, 130, 246, 0.25);
      stroke: var(--accent-blue);
    }

    .asset-base.substation {
      fill: rgba(245, 158, 11, 0.25);
      stroke: var(--accent-warning);
    }

    .asset-base.turbine {
      fill: rgba(139, 92, 246, 0.25);
      stroke: var(--accent-purple);
    }

    .asset-top {
      stroke-width: 1;
      opacity: 0.8;
    }

    .asset-label {
      fill: var(--text-primary);
      font-size: 10px;
      font-weight: 500;
      text-anchor: middle;
      font-family: var(--font-sans);
    }

    .asset-anomaly {
      fill: var(--accent-alert);
      animation: anomaly-pulse 1.5s ease-in-out infinite;
    }

    @keyframes anomaly-pulse {
      0%, 100% { opacity: 0.8; r: 6; }
      50% { opacity: 1; r: 8; }
    }

    /* Drones */
    .drone-group {
      cursor: pointer;
      transition: transform 0.1s ease;
    }

    .drone-shadow {
      fill: rgba(0, 0, 0, 0.3);
      filter: blur(2px);
    }

    .drone-body {
      fill: var(--accent-cyber);
      stroke: #fff;
      stroke-width: 1.5;
      filter: drop-shadow(0 2px 4px rgba(0,0,0,0.3));
    }

    .drone-trail {
      fill: none;
      stroke: var(--accent-cyber);
      stroke-width: 2;
      stroke-linecap: round;
      opacity: 0.4;
    }

    .drone-indicator {
      cursor: pointer;
      transition: transform 0.2s ease;
    }

    .drone-indicator:hover {
      transform: scale(1.2);
    }

    .indicator-ring {
      fill: none;
      stroke-width: 2;
      opacity: 0.6;
    }

    .indicator-ring.reactive { stroke: var(--accent-blue); }
    .indicator-ring.deliberative { stroke: var(--accent-warning); }
    .indicator-ring.reflective { stroke: var(--accent-purple); }
    .indicator-ring.predictive { stroke: var(--accent-cyber); }

    .indicator-core {
      transition: all 0.3s ease;
    }

    .indicator-core.reactive { fill: var(--accent-blue); }
    .indicator-core.deliberative { fill: var(--accent-warning); }
    .indicator-core.reflective { fill: var(--accent-purple); }
    .indicator-core.predictive { fill: var(--accent-cyber); }

    .indicator-pulse {
      fill: none;
      stroke-width: 2;
      opacity: 0;
    }

    .indicator-pulse.active {
      animation: indicator-pulse-anim 1.5s ease-out infinite;
    }

    @keyframes indicator-pulse-anim {
      0% { r: 8; opacity: 0.6; }
      100% { r: 20; opacity: 0; }
    }

    .drone-label {
      fill: var(--text-primary);
      font-size: 10px;
      font-weight: 600;
      text-anchor: middle;
      font-family: var(--font-mono);
    }

    /* ========== THOUGHT BUBBLE (expanded) ========== */
    .thought-bubble {
      position: absolute;
      background: rgba(9, 9, 11, 0.95);
      backdrop-filter: blur(12px);
      border: 1px solid rgba(6, 182, 212, 0.3);
      border-radius: 4px;
      clip-path: polygon(0 0, calc(100% - 12px) 0, 100% 12px, 100% 100%, 12px 100%, 0 calc(100% - 12px));
      padding: 14px 16px;
      min-width: 260px;
      max-width: 320px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 20px rgba(6, 182, 212, 0.15);
      opacity: 0;
      transform: translateY(10px) scale(0.95);
      pointer-events: none;
      transition: opacity 0.25s, transform 0.25s;
      z-index: 200;
      user-select: none;
    }

    .thought-bubble.visible {
      opacity: 1;
      transform: translateY(0) scale(1);
      pointer-events: auto;
    }

    .thought-bubble.dragging {
      transition: none;
      cursor: grabbing;
      box-shadow: 0 15px 50px rgba(0, 0, 0, 0.6), 0 0 30px rgba(6, 182, 212, 0.25);
    }

    .thought-bubble.collapsed {
      min-width: 180px;
      max-width: 200px;
      padding: 10px 12px;
    }

    .thought-bubble.collapsed .bubble-body {
      display: none;
    }

    .thought-bubble.collapsed .bubble-header {
      margin-bottom: 0;
      padding-bottom: 0;
      border-bottom: none;
    }

    .bubble-body {
      transition: all 0.2s ease;
    }

    /* Connector line from bubble to drone */
    .bubble-connector {
      stroke: var(--accent-cyber);
      stroke-width: 1.5;
      stroke-dasharray: 4 3;
      fill: none;
      opacity: 0.6;
      pointer-events: none;
    }

    /* Collapse toggle button */
    .bubble-toggle {
      width: 20px;
      height: 20px;
      border: none;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      color: rgba(255, 255, 255, 0.6);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      margin-left: 8px;
      transition: all 0.15s;
    }

    .bubble-toggle:hover {
      background: rgba(6, 182, 212, 0.3);
      color: var(--accent-cyber);
    }

    .thought-bubble.collapsed .bubble-toggle {
      transform: rotate(180deg);
    }

    /* Drag handle styling */
    .bubble-header {
      cursor: grab;
    }

    .bubble-header:active {
      cursor: grabbing;
    }

    .thought-bubble.deciding {
      border-color: rgba(245, 158, 11, 0.5);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 25px rgba(245, 158, 11, 0.2);
    }

    .thought-bubble.complete {
      border-color: rgba(16, 185, 129, 0.5);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5), 0 0 25px rgba(16, 185, 129, 0.2);
    }

    /* Pointer removed - doesn't work with clip-path angular corners */

    .bubble-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .drone-id {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .drone-icon { font-size: 16px; }

    .drone-name {
      font-weight: 700;
      font-size: 12px;
      color: var(--accent-cyber);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .cognitive-badge {
      padding: 3px 8px;
      border-radius: 10px;
      font-size: 9px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .cognitive-badge.reactive { background: rgba(59, 130, 246, 0.2); color: var(--accent-blue); }
    .cognitive-badge.deliberative { background: rgba(245, 158, 11, 0.2); color: var(--accent-warning); }
    .cognitive-badge.reflective { background: rgba(139, 92, 246, 0.2); color: var(--accent-purple); }
    .cognitive-badge.predictive { background: rgba(6, 182, 212, 0.2); color: var(--accent-cyber); }

    .goal-section { margin-bottom: 10px; }

    .goal-label, .risk-label, .reasoning-label {
      font-size: 9px;
      color: rgba(255, 255, 255, 0.5);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 3px;
    }

    .goal-text {
      font-size: 13px;
      font-weight: 600;
      color: #fff;
    }

    .goal-target {
      font-size: 11px;
      color: var(--accent-cyber);
      margin-top: 2px;
    }

    .risk-section { margin-bottom: 10px; }

    .risk-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px;
    }

    .risk-value {
      font-size: 11px;
      font-weight: 700;
      font-family: var(--font-mono);
    }

    .risk-value.low { color: var(--accent-security); }
    .risk-value.moderate { color: var(--accent-warning); }
    .risk-value.high, .risk-value.critical { color: var(--accent-alert); }

    .risk-bar {
      height: 4px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 2px;
      overflow: hidden;
    }

    .risk-fill {
      height: 100%;
      border-radius: 2px;
      transition: width 0.4s ease;
    }

    .risk-fill.low { background: linear-gradient(90deg, #10b981, #059669); }
    .risk-fill.moderate { background: linear-gradient(90deg, #f59e0b, #d97706); }
    .risk-fill.high, .risk-fill.critical { background: linear-gradient(90deg, #ef4444, #dc2626); }

    .critics-section {
      display: flex;
      gap: 6px;
      margin-bottom: 10px;
    }

    .critic-badge {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 3px;
      padding: 5px 6px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      transition: all 0.2s ease;
    }

    .critic-badge.approve {
      background: rgba(16, 185, 129, 0.12);
      border-color: rgba(16, 185, 129, 0.35);
    }

    .critic-badge.reject {
      background: rgba(239, 68, 68, 0.12);
      border-color: rgba(239, 68, 68, 0.35);
    }

    .critic-icon { font-size: 12px; }

    .critic-name {
      font-size: 8px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.3px;
      color: rgba(255, 255, 255, 0.7);
    }

    .reasoning-section { margin-bottom: 8px; }

    .reasoning-list {
      list-style: none;
      padding: 0;
    }

    .reasoning-item {
      display: flex;
      align-items: flex-start;
      gap: 6px;
      font-size: 11px;
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.3;
      margin-bottom: 3px;
    }

    .reasoning-item::before {
      content: '>';
      color: var(--accent-cyber);
      font-weight: bold;
      flex-shrink: 0;
    }

    .decision-section {
      display: none;
      padding: 10px;
      background: linear-gradient(135deg, rgba(16, 185, 129, 0.15), rgba(5, 150, 105, 0.1));
      border: 1px solid rgba(16, 185, 129, 0.3);
      border-radius: 6px;
      margin-top: 8px;
    }

    .decision-section.active {
      display: block;
      animation: decisionFlash 0.4s ease;
    }

    @keyframes decisionFlash {
      0% { transform: scale(0.95); opacity: 0; }
      50% { transform: scale(1.02); }
      100% { transform: scale(1); opacity: 1; }
    }

    .decision-header {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 6px;
    }

    .decision-icon { font-size: 16px; }

    .decision-action {
      font-size: 14px;
      font-weight: 700;
      color: var(--accent-security);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .decision-confidence {
      margin-left: auto;
      font-size: 12px;
      font-weight: 600;
      font-family: var(--font-mono);
      color: var(--accent-security);
    }

    .decision-reasoning {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.8);
      line-height: 1.3;
    }

    /* Scene info overlay */
    .scene-info {
      position: absolute;
      top: 16px;
      right: 16px;
      background: rgba(9, 9, 11, 0.9);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border-tactical);
      border-radius: 4px;
      clip-path: polygon(0 0, calc(100% - 8px) 0, 100% 8px, 100% 100%, 8px 100%, 0 calc(100% - 8px));
      padding: 12px 14px;
      font-size: 0.75rem;
      color: var(--text-muted);
      z-index: 50;
    }

    .scene-info-row {
      display: flex;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 4px;
    }

    .scene-info-row:last-child { margin-bottom: 0; }

    .scene-info-label { color: var(--text-muted); }
    .scene-info-value { color: var(--text-primary); font-family: var(--font-mono); }

    /* Target info panel */
    .target-info {
      position: absolute;
      bottom: 16px;
      right: 16px;
      background: linear-gradient(135deg, rgba(245, 158, 11, 0.12), rgba(245, 158, 11, 0.08));
      backdrop-filter: blur(12px);
      border: 1px solid rgba(245, 158, 11, 0.35);
      border-radius: 4px;
      clip-path: polygon(0 0, calc(100% - 10px) 0, 100% 10px, 100% 100%, 10px 100%, 0 calc(100% - 10px));
      padding: 14px 18px;
      font-size: 0.75rem;
      z-index: 50;
      min-width: 200px;
      max-width: 240px;
      box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3), 0 0 20px rgba(245, 158, 11, 0.1);
      transition: all 0.3s ease;
    }
    .target-info:hover {
      border-color: rgba(245, 158, 11, 0.5);
      box-shadow: 0 8px 28px rgba(0, 0, 0, 0.35), 0 0 25px rgba(245, 158, 11, 0.15);
    }
    .target-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      padding-bottom: 8px;
      border-bottom: 1px solid rgba(245, 158, 11, 0.2);
    }
    .target-icon {
      font-size: 1.1rem;
      animation: target-pulse 2s ease-in-out infinite;
    }
    @keyframes target-pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(0.95); }
    }
    .target-title {
      color: #f59e0b;
      font-weight: 600;
      font-size: 0.9rem;
      letter-spacing: 0.02em;
      text-shadow: 0 0 10px rgba(245, 158, 11, 0.3);
    }
    .target-coords {
      font-family: var(--font-mono);
      color: var(--text-muted);
      font-size: 0.7rem;
      margin-bottom: 8px;
      display: flex;
      gap: 12px;
    }
    .target-coords .coord {
      display: flex;
      flex-direction: column;
    }
    .target-coords .coord-label {
      font-size: 0.55rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      opacity: 0.6;
      margin-bottom: 2px;
    }
    .target-coords .coord-value {
      color: var(--text-primary);
    }
    .target-delta {
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: rgba(0, 0, 0, 0.2);
      padding: 8px 10px;
      border-radius: 6px;
      margin-top: 4px;
    }
    .delta-label {
      color: var(--text-muted);
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }
    .delta-value {
      color: #f59e0b;
      font-weight: 700;
      font-family: var(--font-mono);
      font-size: 1rem;
      text-shadow: 0 0 8px rgba(245, 158, 11, 0.4);
    }
    .delta-value.close {
      color: var(--accent-security);
      text-shadow: 0 0 8px rgba(16, 185, 129, 0.4);
    }
    .delta-value.far {
      color: var(--accent-alert);
      text-shadow: 0 0 8px rgba(239, 68, 68, 0.4);
    }

    /* Map controls */
    .map-controls {
      position: absolute;
      bottom: 16px;
      left: 16px;
      display: flex;
      flex-direction: column;
      gap: 4px;
      background: rgba(9, 9, 11, 0.9);
      backdrop-filter: blur(8px);
      border: 1px solid var(--border-tactical);
      border-radius: 4px;
      clip-path: polygon(0 0, calc(100% - 6px) 0, 100% 6px, 100% 100%, 6px 100%, 0 calc(100% - 6px));
      padding: 6px;
      z-index: 50;
    }

    /* AirSim Controls styling */
    .airsim-status-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 10px;
      padding: 6px 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
    }

    .airsim-status-label {
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .airsim-status-value {
      font-size: 0.75rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .airsim-status-value.connected {
      color: var(--accent-security);
    }

    .airsim-status-value.disconnected {
      color: var(--accent-alert);
    }

    .airsim-status-value.connecting {
      color: var(--accent-warning);
    }

    .airsim-btn-row {
      display: flex;
      gap: 6px;
      margin-bottom: 6px;
    }

    .airsim-btn-row:last-child {
      margin-bottom: 0;
    }

    .airsim-btn {
      flex: 1;
      padding: 6px 8px;
      font-size: 0.65rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      background: rgba(0, 212, 255, 0.15);
      border: 1px solid rgba(0, 212, 255, 0.3);
      color: var(--accent-cyber);
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .airsim-btn:hover {
      background: rgba(0, 212, 255, 0.25);
      border-color: rgba(0, 212, 255, 0.5);
    }

    .airsim-btn:active {
      transform: scale(0.98);
    }

    .airsim-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .airsim-btn.warn {
      background: rgba(255, 51, 68, 0.15);
      border-color: rgba(255, 51, 68, 0.3);
      color: var(--accent-alert);
    }

    .airsim-btn.warn:hover {
      background: rgba(255, 51, 68, 0.25);
      border-color: rgba(255, 51, 68, 0.5);
    }

    /* SLAM controls styling */
    .slam-controls-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
    }

    .slam-controls-row:last-child {
      margin-bottom: 0;
    }

    .slam-controls-row label {
      flex: 1;
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .slam-toggle {
      position: relative;
      width: 36px;
      height: 18px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 9px;
      cursor: pointer;
      transition: background 0.2s;
      flex-shrink: 0;
    }

    .slam-toggle.active {
      background: rgba(0, 212, 255, 0.3);
    }

    .slam-toggle::after {
      content: "";
      position: absolute;
      top: 2px;
      left: 2px;
      width: 14px;
      height: 14px;
      background: var(--text-muted);
      border-radius: 50%;
      transition: all 0.2s;
    }

    .slam-toggle.active::after {
      left: 20px;
      background: var(--accent-cyber);
    }

    .slam-slider-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .slam-slider-row label {
      font-size: 0.65rem;
      color: var(--text-muted);
      min-width: 60px;
    }

    .slam-slider {
      flex: 1;
      -webkit-appearance: none;
      appearance: none;
      height: 4px;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 2px;
      cursor: pointer;
    }

    .slam-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--accent-cyber);
      cursor: pointer;
      border: 2px solid rgba(0, 0, 0, 0.3);
    }

    .slam-slider::-moz-range-thumb {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: var(--accent-cyber);
      cursor: pointer;
      border: 2px solid rgba(0, 0, 0, 0.3);
    }

    .slam-slider-value {
      font-size: 0.65rem;
      font-family: var(--font-mono);
      color: var(--text-primary);
      min-width: 32px;
      text-align: right;
    }

    .slam-legend {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid var(--border-glass);
    }

    .slam-legend-item {
      display: flex;
      align-items: center;
      gap: 4px;
      font-size: 0.55rem;
      color: var(--text-muted);
    }

    .slam-legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
    }
    .map-btn {
      width: 28px;
      height: 28px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid var(--border-glass);
      border-radius: 4px;
      color: var(--text-primary);
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.15s;
    }
    .map-btn:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    .map-btn.active {
      background: rgba(59, 130, 246, 0.4);
      border-color: rgba(59, 130, 246, 0.6);
      box-shadow: 0 0 6px rgba(59, 130, 246, 0.4);
    }
    .map-btn.active:hover {
      background: rgba(59, 130, 246, 0.5);
    }
    .map-btn.link {
      text-decoration: none;
    }
    .zoom-indicator {
      font-size: 0.65rem;
      color: var(--text-muted);
      text-align: center;
      padding: 2px 0;
      font-family: var(--font-mono);
    }

    /* Target marker pulse animation */
    @keyframes target-pulse {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.5; transform: scale(1.2); }
    }
    .target-ring-pulse {
      animation: target-pulse 2s ease-in-out infinite;
      transform-origin: center;
    }

    /* Empty state */
    .empty-state {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: var(--text-muted);
      z-index: 10;
    }

    .empty-state.hidden { display: none; }

    .empty-icon {
      font-size: 3rem;
      margin-bottom: 12px;
      opacity: 0.3;
    }

    .empty-title {
      font-size: 1rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 6px;
    }

    .empty-text {
      font-size: 0.85rem;
      line-height: 1.4;
    }

    /* Scrollbar */
    ::-webkit-scrollbar { width: 6px; }
    ::-webkit-scrollbar-track { background: transparent; }
    ::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.1); border-radius: 3px; }
    ::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.2); }

    /* Preflight Status Section */
    .preflight-status-bar {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 10px;
      background: rgba(9, 9, 11, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 6px;
    }

    .preflight-status-icon { font-size: 1rem; }

    .preflight-status-text {
      font-size: 0.8rem;
      font-weight: 600;
      color: var(--text-primary);
    }

    .preflight-status-bar.idle .preflight-status-text { color: var(--text-muted); }
    .preflight-status-bar.active .preflight-status-text { color: var(--accent-cyber); }
    .preflight-status-bar.capturing .preflight-status-text { color: var(--accent-blue); }
    .preflight-status-bar.processing .preflight-status-text { color: var(--accent-purple); }
    .preflight-status-bar.complete .preflight-status-text { color: var(--accent-security); }
    .preflight-status-bar.failed .preflight-status-text { color: var(--accent-alert); }
    .preflight-status-bar.timeout .preflight-status-text { color: var(--accent-warning); }
    .preflight-status-bar.skipped .preflight-status-text { color: var(--text-muted); }
    .preflight-status-bar.recovering .preflight-status-text { color: var(--accent-warning); }
    .preflight-status-bar.recovery_failed .preflight-status-text { color: var(--accent-alert); }

    .preflight-progress-container {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
    }

    .preflight-progress-bar {
      flex: 1;
      height: 6px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 3px;
      overflow: hidden;
    }

    .preflight-progress-fill {
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, var(--accent-cyber), var(--accent-blue));
      border-radius: 3px;
      transition: width 0.3s ease;
    }

    .preflight-progress-text {
      font-size: 0.7rem;
      font-family: var(--font-mono);
      color: var(--text-muted);
      min-width: 32px;
      text-align: right;
    }

    .preflight-message {
      margin-top: 8px;
      padding: 6px 8px;
      background: rgba(9, 9, 11, 0.6);
      border: 1px solid rgba(255, 255, 255, 0.06);
      border-radius: 4px;
      font-size: 0.7rem;
      color: rgba(250, 250, 250, 0.7);
      line-height: 1.3;
    }

    .preflight-message.error {
      border-color: rgba(239, 68, 68, 0.35);
      background: rgba(239, 68, 68, 0.08);
    }

    .preflight-message.warning {
      border-color: rgba(245, 158, 11, 0.35);
      background: rgba(245, 158, 11, 0.08);
    }

    .preflight-message.success {
      border-color: rgba(16, 185, 129, 0.35);
      background: rgba(16, 185, 129, 0.08);
    }
  </style>
</head>

<body>
  <!-- LEFT SIDEBAR -->
  <aside class="sidebar">
    <div class="sidebar-header">
      <span class="sidebar-title">AegisAV</span>
      <div class="connection-status connecting" id="connectionStatus">Connecting</div>
    </div>

    <div class="sidebar-content">
      <!-- Scenario Controls -->
      <div class="sidebar-section">
        <div class="section-header" data-section="scenario">
          <span class="section-title">Scenario Controls</span>
          <button class="section-toggle">-</button>
        </div>
        <div class="section-content" id="scenarioSection">
          <select id="scenarioSelect">
            <option value="">Loading scenarios...</option>
          </select>
          <div class="btn-row">
            <button id="scenarioStart" class="btn primary">Start</button>
            <button id="scenarioStop" class="btn">Stop</button>
          </div>
          <div class="status-text" id="scenarioStatus">Idle</div>
          <a id="dashboardLink" class="btn link-btn" href="#" target="_blank" rel="noreferrer">Open Dashboard</a>
        </div>
      </div>

      <!-- Debug Flight Controls (moved up for visibility) -->
      <div class="sidebar-section">
        <div class="section-header" data-section="debug">
          <span class="section-title">Flight Debug</span>
          <button class="section-toggle">-</button>
        </div>
        <div class="section-content" id="debugSection">
          <div class="btn-row">
            <button id="debugTakeoff" class="btn primary">Take Off</button>
            <button id="debugLand" class="btn">Land</button>
          </div>
          <div class="btn-row">
            <button id="debugRTL" class="btn">Return to Dock</button>
            <button id="debugGoTarget" class="btn">Go to Target</button>
          </div>
          <div class="btn-row">
            <button id="debugReset" class="btn" style="border-color: rgba(239, 68, 68, 0.35); background: rgba(239, 68, 68, 0.08);">Reset Drone</button>
          </div>
          <div class="status-text" id="debugStatus">Ready</div>
          <div class="base-station-grid" style="margin-top: 8px;">
            <div class="base-stat">
              <div class="base-stat-label">Position</div>
              <div class="base-stat-value" id="debugPosition" style="font-size: 0.7rem;">--</div>
            </div>
            <div class="base-stat">
              <div class="base-stat-label">Altitude</div>
              <div class="base-stat-value" id="debugAltitude">-- m</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Preflight Status -->
      <div class="sidebar-section" id="preflightSection">
        <div class="section-header" data-section="preflight">
          <span class="section-title">Preflight Status</span>
          <button class="section-toggle">-</button>
        </div>
        <div class="section-content" id="preflightContent">
          <div class="preflight-status-bar">
            <span class="preflight-status-icon" id="preflightIcon">‚è∏Ô∏è</span>
            <span class="preflight-status-text" id="preflightStatusText">Idle</span>
          </div>
          <div class="preflight-progress-container" id="preflightProgressContainer" style="display: none;">
            <div class="preflight-progress-bar">
              <div class="preflight-progress-fill" id="preflightProgressFill"></div>
            </div>
            <div class="preflight-progress-text" id="preflightProgressText">0%</div>
          </div>
          <div class="base-station-grid" style="margin-top: 8px;">
            <div class="base-stat">
              <div class="base-stat-label">Mapping</div>
              <div class="base-stat-value" id="preflightMapping">--</div>
            </div>
            <div class="base-stat">
              <div class="base-stat-label">Captures</div>
              <div class="base-stat-value" id="preflightCaptures">0</div>
            </div>
            <div class="base-stat">
              <div class="base-stat-label">SLAM</div>
              <div class="base-stat-value" id="preflightSlam">--</div>
            </div>
            <div class="base-stat">
              <div class="base-stat-label">Quality</div>
              <div class="base-stat-value" id="preflightQuality">--</div>
            </div>
          </div>
          <div class="preflight-message" id="preflightMessage" style="display: none;">
            <span class="preflight-message-text"></span>
          </div>
        </div>
      </div>

      <!-- AirSim Controls -->
      <div class="sidebar-section">
        <div class="section-header" data-section="airsimcontrols">
          <span class="section-title">AirSim Controls</span>
          <button class="section-toggle">-</button>
        </div>
        <div class="section-content" id="airsimControlsSection">
          <div class="airsim-status-row">
            <span class="airsim-status-label">Status:</span>
            <span class="airsim-status-value" id="airsimStatusValue">Unknown</span>
          </div>
          <div class="airsim-btn-row">
            <button class="btn airsim-btn" id="airsimLaunchBtn" title="Launch AirSim application">
              Launch
            </button>
            <button class="btn airsim-btn" id="airsimReconnectBtn" title="Reconnect to AirSim">
              Reconnect
            </button>
          </div>
          <div class="airsim-btn-row">
            <button class="btn airsim-btn" id="airsimResetDroneBtn" title="Reset drone to starting position">
              Reset Drone
            </button>
            <button class="btn airsim-btn warn" id="airsimForceCloseBtn" title="Force close AirSim (taskkill)">
              Force Close
            </button>
          </div>
          <div class="airsim-btn-row">
            <button class="btn airsim-btn" id="refreshOverlayBtn" title="Refresh overlay and reconnect WebSocket">
              Refresh UI
            </button>
            <button class="btn airsim-btn" id="syncSceneBtn" title="Sync scenario scene to AirSim">
              Sync Scene
            </button>
          </div>
        </div>
      </div>

      <!-- SLAM/Map Display Configuration -->
      <div class="sidebar-section">
        <div class="section-header" data-section="slamconfig">
          <span class="section-title">SLAM Display</span>
          <button class="section-toggle">-</button>
        </div>
        <div class="section-content" id="slamConfigSection">
          <div class="slam-controls-row">
            <label>Show Obstacles</label>
            <div class="slam-toggle active" id="slamObstaclesToggle" data-key="showObstacles" title="Show/hide SLAM obstacles"></div>
          </div>
          <div class="slam-controls-row">
            <label>Show Point Cloud</label>
            <div class="slam-toggle active" id="slamPointsToggle" data-key="showPoints" title="Show/hide point cloud"></div>
          </div>
          <div class="slam-controls-row">
            <label>Heatmap Mode</label>
            <div class="slam-toggle" id="slamHeatmapToggle" data-key="heatmapMode" title="Color by height"></div>
          </div>
          <div class="slam-slider-row">
            <label>Max Height</label>
            <input type="range" class="slam-slider" id="slamHeightMax" min="0" max="100" value="100" title="Filter obstacles by max height">
            <span class="slam-slider-value" id="slamHeightMaxValue">100m</span>
          </div>
          <div class="slam-slider-row">
            <label>Min Height</label>
            <input type="range" class="slam-slider" id="slamHeightMin" min="0" max="100" value="0" title="Filter obstacles by min height">
            <span class="slam-slider-value" id="slamHeightMinValue">0m</span>
          </div>
          <div class="slam-slider-row">
            <label>Point Size</label>
            <input type="range" class="slam-slider" id="slamPointSize" min="1" max="10" value="3" title="Point cloud dot size">
            <span class="slam-slider-value" id="slamPointSizeValue">3</span>
          </div>
          <div class="slam-slider-row">
            <label>Opacity</label>
            <input type="range" class="slam-slider" id="slamOpacity" min="10" max="100" value="70" title="Point opacity">
            <span class="slam-slider-value" id="slamOpacityValue">70%</span>
          </div>
          <div class="slam-slider-row">
            <label>Offset X</label>
            <input type="range" class="slam-slider" id="slamOffsetX" min="-200" max="200" value="0" title="East/West offset (meters)">
            <span class="slam-slider-value" id="slamOffsetXValue">0m</span>
          </div>
          <div class="slam-slider-row">
            <label>Offset Y</label>
            <input type="range" class="slam-slider" id="slamOffsetY" min="-200" max="200" value="0" title="North/South offset (meters)">
            <span class="slam-slider-value" id="slamOffsetYValue">0m</span>
          </div>
          <div class="slam-slider-row">
            <label>View Tilt</label>
            <input type="range" class="slam-slider" id="slamViewAngle" min="5" max="90" value="30" title="View tilt angle (5=top-down, 90=edge-on)">
            <span class="slam-slider-value" id="slamViewAngleValue">30¬∞</span>
          </div>
          <div class="slam-slider-row">
            <label>Rotation</label>
            <input type="range" class="slam-slider" id="slamRotation" min="0" max="360" value="45" title="Scene rotation angle">
            <span class="slam-slider-value" id="slamRotationValue">45¬∞</span>
          </div>
          <div class="slam-legend">
            <div class="slam-legend-item"><span class="slam-legend-dot" style="background:#ef4444"></span>Building</div>
            <div class="slam-legend-item"><span class="slam-legend-dot" style="background:#22c55e"></span>Tree</div>
            <div class="slam-legend-item"><span class="slam-legend-dot" style="background:#3b82f6"></span>Solar</div>
            <div class="slam-legend-item"><span class="slam-legend-dot" style="background:#8b5cf6"></span>Substation</div>
            <div class="slam-legend-item"><span class="slam-legend-dot" style="background:#06b6d4"></span>Turbine</div>
          </div>
        </div>
      </div>

      <!-- Camera -->
      <div class="sidebar-section">
        <div class="section-header" data-section="camera">
          <span class="section-title">Drone Camera</span>
          <button class="section-toggle">-</button>
        </div>
        <div class="section-content" id="cameraSection">
          <!-- Drone selector tabs -->
          <div class="drone-camera-tabs" id="droneCameraTabs">
            <!-- Dynamically populated -->
          </div>
          <div class="camera-view" id="cameraView">
            <div class="camera-placeholder" id="cameraPlaceholder">
              <div class="camera-placeholder-icon">üìπ</div>
              <div>No stream</div>
            </div>
            <img id="cameraImage" style="display: none;" alt="Drone camera">
            <div class="camera-fps" id="cameraFps" style="display: none;">-- FPS</div>
            <div class="camera-overlay" id="cameraOverlay" style="display: none;">
              <span id="cameraDroneName">--</span>
              <span id="cameraStreamStatus">LIVE</span>
            </div>
          </div>
          <!-- Thumbnail strip for other drones -->
          <div class="camera-thumbnails" id="cameraThumbnails">
            <!-- Dynamically populated -->
          </div>
          <div class="btn-row">
            <button class="btn primary" id="cameraStartBtn">Start</button>
            <button class="btn" id="cameraStopBtn" disabled>Stop</button>
          </div>
        </div>
      </div>

      <!-- Base Station -->
      <div class="sidebar-section">
        <div class="section-header" data-section="basestation">
          <span class="section-title">Base Station</span>
          <button class="section-toggle">-</button>
        </div>
        <div class="section-content" id="basestationSection">
          <div class="base-station-grid">
            <div class="base-stat">
              <div class="base-stat-label">Status</div>
              <div class="base-stat-value" id="baseStatus">
                <span class="status-dot online"></span>
                Online
              </div>
            </div>
            <div class="base-stat">
              <div class="base-stat-label">Docked</div>
              <div class="base-stat-value" id="baseDocked">0 / 1</div>
            </div>
            <div class="base-stat">
              <div class="base-stat-label">Charging</div>
              <div class="base-stat-value" id="baseCharging">--</div>
            </div>
            <div class="base-stat">
              <div class="base-stat-label">Weather</div>
              <div class="base-stat-value" id="baseWeather">Clear</div>
            </div>
            <div class="base-stat">
              <div class="base-stat-label">Wind</div>
              <div class="base-stat-value" id="baseWind">-- kts</div>
            </div>
            <div class="base-stat">
              <div class="base-stat-label">Decisions</div>
              <div class="base-stat-value" id="decisionCount" style="color: var(--accent-cyber)">0</div>
            </div>
            <div class="base-stat">
              <div class="base-stat-label">Signal</div>
              <div class="base-stat-value" id="baseSignal">
                <span class="signal-bars">
                  <span class="bar active"></span>
                  <span class="bar active"></span>
                  <span class="bar active"></span>
                  <span class="bar"></span>
                </span>
                Good
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Log -->
      <div class="sidebar-section" style="flex: 1; min-height: 0;">
        <div class="section-header" data-section="log">
          <span class="section-title">Scenario Log</span>
          <button class="section-toggle">-</button>
        </div>
        <div class="section-content" id="logSection">
          <div class="log-list" id="scenarioLogList">
            <div class="log-empty" id="scenarioLogEmpty">No activity yet.</div>
          </div>
        </div>
      </div>
    </div>
  </aside>

  <!-- MAIN SCENE -->
  <main class="scene-container" id="sceneContainer">
    <svg class="scene-svg" id="sceneSvg">
      <defs>
        <filter id="glow">
          <feGaussianBlur stdDeviation="2" result="coloredBlur"/>
          <feMerge>
            <feMergeNode in="coloredBlur"/>
            <feMergeNode in="SourceGraphic"/>
          </feMerge>
        </filter>
      </defs>
      <g id="gridLayer"></g>
      <g id="groundLayer"></g>
      <g id="mapLayer"></g>
      <g id="assetLayer"></g>
      <g id="trailLayer"></g>
      <g id="droneLayer"></g>
      <g id="connectorLayer"></g>
    </svg>

    <div class="scene-info" id="sceneInfo" style="display: none;">
      <div class="scene-info-row">
        <span class="scene-info-label">Scenario:</span>
        <span class="scene-info-value" id="infoScenario">--</span>
      </div>
      <div class="scene-info-row">
        <span class="scene-info-label">Drones:</span>
        <span class="scene-info-value" id="infoDrones">0</span>
      </div>
      <div class="scene-info-row">
        <span class="scene-info-label">Assets:</span>
        <span class="scene-info-value" id="infoAssets">0</span>
      </div>
    </div>

    <!-- Target Info Panel -->
    <div class="target-info" id="targetInfo" style="display: none;">
      <div class="target-header">
        <span class="target-icon">&#127919;</span>
        <span class="target-title" id="targetName">Target</span>
      </div>
      <div class="target-coords" id="targetCoords">
        <div class="coord">
          <span class="coord-label">X</span>
          <span class="coord-value" id="targetX">--</span>
        </div>
        <div class="coord">
          <span class="coord-label">Y</span>
          <span class="coord-value" id="targetY">--</span>
        </div>
      </div>
      <div class="target-delta">
        <span class="delta-label">Distance</span>
        <span class="delta-value" id="targetDelta">--</span>
      </div>
    </div>

    <!-- Map Controls -->
    <div class="map-controls" id="mapControls">
      <button class="map-btn" id="zoomIn" title="Zoom In">+</button>
      <span class="zoom-indicator" id="zoomIndicator">100%</span>
      <button class="map-btn" id="zoomOut" title="Zoom Out">‚àí</button>
      <button class="map-btn" id="fitView" title="Fit to Map">‚§¢</button>
      <button class="map-btn" id="resetView" title="Reset View">‚åÇ</button>
      <button class="map-btn active" id="autoFitToggle" title="Auto-Fit (click to toggle)">üéØ</button>
      <a class="map-btn link" id="openFullMap" title="Open Full Map" href="#" target="_blank" rel="noreferrer">üó∫</a>
    </div>

    <div class="empty-state" id="emptyState">
      <div class="empty-icon">üöÅ</div>
      <div class="empty-title">Waiting for Scenario</div>
      <div class="empty-text">Start a scenario to visualize<br>drone operations and decisions.</div>
    </div>

    <!-- Thought bubbles will be positioned here -->
    <div id="thoughtBubbles"></div>
  </main>

  <script>
    // ========== CONFIGURATION ==========
    const wsProtocol = window.location.protocol === 'https:' ? 'wss' : 'ws';
    const httpBase = `${window.location.protocol}//${window.location.host}`;
    const wsBase = `${wsProtocol}://${window.location.host}`;

    const CONFIG = {
      serverUrl: `${wsBase}/ws/unreal`,
      httpBase,
      reconnectDelay: 3000,
      thoughtTimeout: 8000,
      // Isometric settings
      isoAngle: Math.PI / 6, // 30 degrees
      scale: 3, // pixels per meter
      originX: 0, // Set dynamically
      originY: 0, // Set dynamically
      // Pan/zoom settings
      panX: 0,
      panY: 0,
      zoom: 1.0,
      minZoom: 0.3,
      maxZoom: 5.0,
      // Reference point (dock location)
      dockLat: 37.7749,
      dockLon: -122.4194,
      mapScale: 0.25,
      mapOffsetX: -60,
      mapOffsetY: 60,
      mapHeightM: 20
    };

    // ========== STATE ==========
    const state = {
      socket: null,
      connected: false,
      // Scene data
      scenario: null,
      scenarioIdleCount: 0,
      assets: new Map(), // assetId -> { data, element }
      drones: new Map(), // droneId -> { data, element, trail, indicator, bubble, timeout, thinking }
      mapPreview: null,
      mapStatus: null,
      // SLAM/Navigation data
      slamObstacles: [],
      splatPoints: [],
      previewPoints: [],
      splatLoading: false,
      // Target/Mission objective
      target: null, // { x, y, z, lat, lon, name, assetId }
      // Pan/Zoom state
      isPanning: false,
      panStartX: 0,
      panStartY: 0,
      lastPanX: 0,
      lastPanY: 0,
      autoFitEnabled: true,
      lastFitSignature: null,
      // UI
      expandedDroneId: null,
      dockLocked: false,
      dockSource: null
    };

    // ========== DOM ELEMENTS ==========
    const statusEl = document.getElementById('connectionStatus');
    const scenarioSelect = document.getElementById('scenarioSelect');
    const scenarioStart = document.getElementById('scenarioStart');
    const scenarioStop = document.getElementById('scenarioStop');
    const scenarioStatus = document.getElementById('scenarioStatus');
    const dashboardLink = document.getElementById('dashboardLink');
    const scenarioLogList = document.getElementById('scenarioLogList');
    const scenarioLogEmpty = document.getElementById('scenarioLogEmpty');
    const emptyState = document.getElementById('emptyState');
    const sceneInfo = document.getElementById('sceneInfo');
    const sceneSvg = document.getElementById('sceneSvg');
    const gridLayer = document.getElementById('gridLayer');
    const groundLayer = document.getElementById('groundLayer');
    const mapLayer = document.getElementById('mapLayer');
    const assetLayer = document.getElementById('assetLayer');
    const trailLayer = document.getElementById('trailLayer');
    const droneLayer = document.getElementById('droneLayer');
    const thoughtBubbles = document.getElementById('thoughtBubbles');

    // Camera
    const cameraImage = document.getElementById('cameraImage');
    const cameraPlaceholder = document.getElementById('cameraPlaceholder');
    const cameraFps = document.getElementById('cameraFps');
    const cameraOverlay = document.getElementById('cameraOverlay');
    const cameraDroneName = document.getElementById('cameraDroneName');
    const cameraStreamStatus = document.getElementById('cameraStreamStatus');
    const cameraStartBtn = document.getElementById('cameraStartBtn');
    const cameraStopBtn = document.getElementById('cameraStopBtn');
    const droneCameraTabs = document.getElementById('droneCameraTabs');
    const cameraThumbnails = document.getElementById('cameraThumbnails');

    // SLAM Display Configuration
    const slamConfig = {
      showObstacles: true,
      showPoints: true,
      heatmapMode: false,
      heightMin: 0,      // meters
      heightMax: 100,    // meters
      pointSize: 3,
      opacity: 0.7,
      // Offset to align SLAM NED coords with drone GPS-based coords
      offsetX: 0,        // meters (East offset)
      offsetY: 0,        // meters (North offset)
      // View angle controls
      viewAngle: 30,     // degrees (0 = top-down, 90 = edge-on)
      rotationAngle: 45  // degrees rotation around vertical axis
    };

    const cameraState = {
      streaming: false,
      droneId: null,
      selectedDroneId: null,  // Currently viewing
      streamingDrones: new Set(),  // All drones that are streaming
      availableVehicles: new Set(), // From /api/camera/status
      frames: new Map(),  // droneId -> last frame data
      frameCount: 0,
      lastFrameTime: 0,
      fps: 0
    };

    dashboardLink.href = `${CONFIG.httpBase}/dashboard`;
    const fullMapLink = document.getElementById('openFullMap');
    if (fullMapLink) {
      fullMapLink.href = `${CONFIG.httpBase}/dashboard/maps`;
    }

    // ========== ISOMETRIC HELPERS ==========
    function gpsToLocal(lat, lon) {
      // Convert GPS to local meters (simple approximation)
      // Handle undefined/null/NaN inputs gracefully
      const safeLat = (lat != null && !Number.isNaN(lat)) ? lat : CONFIG.dockLat;
      const safeLon = (lon != null && !Number.isNaN(lon)) ? lon : CONFIG.dockLon;
      const latDiff = (safeLat - CONFIG.dockLat) * 111320; // meters per degree lat
      const lonDiff = (safeLon - CONFIG.dockLon) * 111320 * Math.cos(CONFIG.dockLat * Math.PI / 180);
      return { x: lonDiff, y: -latDiff }; // Flip Y for screen coords
    }

    function setDockReference(lat, lon, source, options = {}) {
      const { force = false, lock = false } = options;
      if (state.dockLocked && !force) return false;
      const nextLat = Number(lat);
      const nextLon = Number(lon);
      if (!Number.isFinite(nextLat) || !Number.isFinite(nextLon)) return false;

      const changed =
        Math.abs(nextLat - CONFIG.dockLat) > 1e-6 ||
        Math.abs(nextLon - CONFIG.dockLon) > 1e-6;
      if (!changed) {
        if (lock) state.dockLocked = true;
        return false;
      }

      CONFIG.dockLat = nextLat;
      CONFIG.dockLon = nextLon;
      state.dockSource = source || state.dockSource;
      if (lock) state.dockLocked = true;

      if (state.target && Number.isFinite(state.target.lat) && Number.isFinite(state.target.lon)) {
        const local = gpsToLocal(state.target.lat, state.target.lon);
        state.target.x = local.x;
        state.target.y = local.y;
      }

      redrawScene();
      maybeAutoFit();
      return true;
    }

    function toIsoCoords(x, y, z = 0) {
      // Use configurable view angles from slamConfig
      const pitchRad = (slamConfig.viewAngle * Math.PI) / 180;  // Tilt angle (0=top, 90=side)
      const rotRad = (slamConfig.rotationAngle * Math.PI) / 180; // Rotation around Z axis

      // First rotate around vertical axis
      const cosRot = Math.cos(rotRad);
      const sinRot = Math.sin(rotRad);
      const rx = x * cosRot - y * sinRot;
      const ry = x * sinRot + y * cosRot;

      // Then apply pitch (tilt) - affects how much Y compresses and Z shows
      const cosPitch = Math.cos(pitchRad);
      const sinPitch = Math.sin(pitchRad);

      return {
        isoX: rx,
        isoY: ry * sinPitch - z * cosPitch
      };
    }

    function toIsometric(x, y, z = 0) {
      const iso = toIsoCoords(x, y, z);
      const effectiveScale = CONFIG.scale * CONFIG.zoom;
      return {
        screenX: CONFIG.originX + CONFIG.panX + iso.isoX * effectiveScale,
        screenY: CONFIG.originY + CONFIG.panY + iso.isoY * effectiveScale
      };
    }

    function updateOrigin() {
      const rect = sceneSvg.getBoundingClientRect();
      CONFIG.originX = rect.width / 2;
      CONFIG.originY = rect.height / 2 + 50; // Offset down a bit
    }

    // ========== PAN/ZOOM CONTROLS ==========
    function setupPanZoom() {
      const svg = sceneSvg;

      // Mouse wheel zoom
      let zoomRAF = null;
      svg.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        const newZoom = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, CONFIG.zoom * delta));

        // Zoom toward mouse position
        const rect = svg.getBoundingClientRect();
        const mouseX = e.clientX - rect.left - CONFIG.originX;
        const mouseY = e.clientY - rect.top - CONFIG.originY;

        // Adjust pan to keep mouse position fixed
        const zoomRatio = newZoom / CONFIG.zoom;
        CONFIG.panX = mouseX - (mouseX - CONFIG.panX) * zoomRatio;
        CONFIG.panY = mouseY - (mouseY - CONFIG.panY) * zoomRatio;
        CONFIG.zoom = newZoom;

        // Disable auto-fit when user manually zooms
        state.autoFitEnabled = false;
        updateAutoFitIndicator();
        updateZoomIndicator();

        // Throttle redraws
        if (!zoomRAF) {
          zoomRAF = requestAnimationFrame(() => {
            redrawScene();
            zoomRAF = null;
          });
        }
      }, { passive: false });

      // Mouse drag pan
      svg.addEventListener('mousedown', (e) => {
        if (e.button === 0) { // Left mouse button
          state.isPanning = true;
          state.panStartX = e.clientX;
          state.panStartY = e.clientY;
          state.lastPanX = CONFIG.panX;
          state.lastPanY = CONFIG.panY;
          svg.style.cursor = 'grabbing';
        }
      });

      let panRAF = null;
      document.addEventListener('mousemove', (e) => {
        if (state.isPanning) {
          const dx = e.clientX - state.panStartX;
          const dy = e.clientY - state.panStartY;
          CONFIG.panX = state.lastPanX + dx;
          CONFIG.panY = state.lastPanY + dy;

          // Throttle redraws using requestAnimationFrame
          if (!panRAF) {
            panRAF = requestAnimationFrame(() => {
              redrawScene();
              panRAF = null;
            });
          }
        }
      });

      document.addEventListener('mouseup', () => {
        if (state.isPanning) {
          state.isPanning = false;
          sceneSvg.style.cursor = 'grab';
          // Disable auto-fit when user manually pans
          state.autoFitEnabled = false;
          updateAutoFitIndicator();
        }
      });

      // Set initial cursor
      svg.style.cursor = 'grab';
    }

    function resetPanZoom() {
      CONFIG.panX = 0;
      CONFIG.panY = 0;
      CONFIG.zoom = 1.0;
      redrawScene();
      updateZoomIndicator();
    }

    function updateZoomIndicator() {
      const indicator = document.getElementById('zoomIndicator');
      if (indicator) {
        indicator.textContent = `${Math.round(CONFIG.zoom * 100)}%`;
      }
    }

    function updateAutoFitIndicator() {
      const btn = document.getElementById('autoFitToggle');
      if (btn) {
        if (state.autoFitEnabled) {
          btn.classList.add('active');
          btn.title = 'Auto-Fit ON (click to disable)';
        } else {
          btn.classList.remove('active');
          btn.title = 'Auto-Fit OFF (click to enable)';
        }
      }
    }

    function toggleAutoFit() {
      state.autoFitEnabled = !state.autoFitEnabled;
      updateAutoFitIndicator();
      if (state.autoFitEnabled) {
        // Re-fit immediately when enabled
        state.lastFitSignature = null;
        maybeAutoFit();
      }
    }

    function resetCameraState() {
      // Reset view to defaults and re-enable auto-fit
      resetPanZoom();
      state.autoFitEnabled = true;
      state.lastFitSignature = null;
      updateAutoFitIndicator();
    }

    function redrawScene() {
      // Clear layers that need full redraw
      gridLayer.innerHTML = '';
      groundLayer.innerHTML = '';
      mapLayer.innerHTML = '';

      // Redraw static elements
      renderGrid();
      renderDock();

      // Redraw map data - SLAM obstacles integrate into the main view
      // Note: Map cube preview removed as it was a confusing separate visualization
      // SLAM obstacles and splat points render directly in the coordinate space
      renderSlamObstacles();
      renderSplatPoints();
      renderTarget();

      // Re-render assets - save data, clear, rebuild
      const assetsData = Array.from(state.assets.values()).map(a => a.data).filter(Boolean);
      assetLayer.innerHTML = '';
      state.assets.clear();
      assetsData.forEach(data => renderAsset(data));

      // Re-render drones - save data, clear, rebuild
      const dronesData = Array.from(state.drones.values()).map(d => d.data).filter(Boolean);
      droneLayer.innerHTML = '';
      trailLayer.innerHTML = '';
      thoughtBubbles.innerHTML = '';
      state.drones.clear();
      dronesData.forEach(data => renderDrone(data));
    }

    // ========== SCENE RENDERING ==========
    function clearScene() {
      gridLayer.innerHTML = '';
      groundLayer.innerHTML = '';
      mapLayer.innerHTML = '';
      assetLayer.innerHTML = '';
      trailLayer.innerHTML = '';
      droneLayer.innerHTML = '';
      thoughtBubbles.innerHTML = '';
      state.assets.clear();
      state.drones.clear();
      state.mapPreview = null;
      state.mapStatus = null;
      state.slamObstacles = [];
      state.splatPoints = [];
      state.previewPoints = [];
      state.target = null;
      state.expandedDroneId = null;
      state.autoFitEnabled = true;
      state.lastFitSignature = null;
    }

    function renderGrid() {
      // Clear existing grid lines before re-rendering
      gridLayer.innerHTML = '';
      updateOrigin();
      const gridSize = 100; // meters
      const step = 25; // meters per line

      for (let i = -gridSize; i <= gridSize; i += step) {
        // Lines along X axis (going NE-SW in iso)
        const start1 = toIsometric(-gridSize, i);
        const end1 = toIsometric(gridSize, i);
        const line1 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line1.setAttribute('x1', start1.screenX);
        line1.setAttribute('y1', start1.screenY);
        line1.setAttribute('x2', end1.screenX);
        line1.setAttribute('y2', end1.screenY);
        line1.setAttribute('class', i === 0 ? 'major' : '');
        gridLayer.appendChild(line1);

        // Lines along Y axis (going NW-SE in iso)
        const start2 = toIsometric(i, -gridSize);
        const end2 = toIsometric(i, gridSize);
        const line2 = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line2.setAttribute('x1', start2.screenX);
        line2.setAttribute('y1', start2.screenY);
        line2.setAttribute('x2', end2.screenX);
        line2.setAttribute('y2', end2.screenY);
        line2.setAttribute('class', i === 0 ? 'major' : '');
        gridLayer.appendChild(line2);
      }
      gridLayer.setAttribute('class', 'iso-grid');
    }

    function getLocalBounds() {
      let hasBounds = false;
      let minX = Infinity;
      let maxX = -Infinity;
      let minY = Infinity;
      let maxY = -Infinity;
      let minZ = Infinity;
      let maxZ = -Infinity;

      const includePoint = (x, y, z = 0, padding = 0) => {
        if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(z)) return;
        hasBounds = true;
        minX = Math.min(minX, x - padding);
        maxX = Math.max(maxX, x + padding);
        minY = Math.min(minY, y - padding);
        maxY = Math.max(maxY, y + padding);
        minZ = Math.min(minZ, z);
        maxZ = Math.max(maxZ, z);
      };

      const includeBoundsCorners = (minXLocal, maxXLocal, minYLocal, maxYLocal, z = 0) => {
        includePoint(minXLocal, minYLocal, z);
        includePoint(minXLocal, maxYLocal, z);
        includePoint(maxXLocal, minYLocal, z);
        includePoint(maxXLocal, maxYLocal, z);
      };

      if (state.slamObstacles && state.slamObstacles.length > 0) {
        state.slamObstacles.forEach(obs => {
          const nedX = obs.x ?? obs.x_ned ?? 0;
          const nedY = obs.y ?? obs.y_ned ?? 0;
          const localX = nedY;
          const localY = -nedX;
          const radius = obs.r ?? obs.radius_m ?? 0;
          const height = obs.h ?? obs.height_m ?? 0;
          includePoint(localX, localY, 0, radius);
          if (height > 0) includePoint(localX, localY, height, radius);
        });
      }

      const points = state.splatPoints.length > 0 ? state.splatPoints : state.previewPoints;
      if (points && points.length > 0) {
        const stride = Math.max(1, Math.floor(points.length / 2000));
        for (let i = 0; i < points.length; i += stride) {
          const pt = points[i];
          const localX = pt.y;
          const localY = -pt.x;
          includePoint(localX, localY, pt.z || 0);
        }
      }

      if (!hasBounds && state.mapPreview && state.mapPreview.bounds) {
        const bounds = state.mapPreview.bounds;
        if ([bounds.min_x, bounds.max_x, bounds.min_y, bounds.max_y].every(Number.isFinite)) {
          const localMinX = bounds.min_y;
          const localMaxX = bounds.max_y;
          const localMinY = -bounds.max_x;
          const localMaxY = -bounds.min_x;
          includeBoundsCorners(localMinX, localMaxX, localMinY, localMaxY, 0);
        }
      }

      if (!hasBounds && state.assets.size > 0) {
        state.assets.forEach(asset => {
          if (asset && asset.data) {
            includePoint(asset.data.localX, asset.data.localY, asset.data.alt || 0);
          }
        });
      }

      if (!hasBounds && state.drones.size > 0) {
        state.drones.forEach(drone => {
          if (drone && drone.data) {
            includePoint(drone.data.localX || 0, drone.data.localY || 0, drone.data.altitude_agl || 0);
          }
        });
      }

      if (!hasBounds) return null;
      if (!Number.isFinite(minZ)) minZ = 0;
      if (!Number.isFinite(maxZ)) maxZ = 0;
      return { minX, maxX, minY, maxY, minZ, maxZ };
    }

    function fitToMapView(boundsOverride = null) {
      const bounds = boundsOverride || getLocalBounds();
      if (!bounds) return false;

      const rect = sceneSvg.getBoundingClientRect();
      if (rect.width <= 0 || rect.height <= 0) return false;

      const corners = [
        { x: bounds.minX, y: bounds.minY, z: bounds.minZ },
        { x: bounds.minX, y: bounds.maxY, z: bounds.minZ },
        { x: bounds.maxX, y: bounds.minY, z: bounds.minZ },
        { x: bounds.maxX, y: bounds.maxY, z: bounds.minZ },
        { x: bounds.minX, y: bounds.minY, z: bounds.maxZ },
        { x: bounds.minX, y: bounds.maxY, z: bounds.maxZ },
        { x: bounds.maxX, y: bounds.minY, z: bounds.maxZ },
        { x: bounds.maxX, y: bounds.maxY, z: bounds.maxZ }
      ];

      let minIsoX = Infinity;
      let maxIsoX = -Infinity;
      let minIsoY = Infinity;
      let maxIsoY = -Infinity;

      corners.forEach(pt => {
        const iso = toIsoCoords(pt.x, pt.y, pt.z);
        minIsoX = Math.min(minIsoX, iso.isoX);
        maxIsoX = Math.max(maxIsoX, iso.isoX);
        minIsoY = Math.min(minIsoY, iso.isoY);
        maxIsoY = Math.max(maxIsoY, iso.isoY);
      });

      const spanX = Math.max(1, maxIsoX - minIsoX);
      const spanY = Math.max(1, maxIsoY - minIsoY);
      const padding = 80;
      const availableWidth = Math.max(100, rect.width - padding * 2);
      const availableHeight = Math.max(100, rect.height - padding * 2);
      const targetScale = Math.min(availableWidth / spanX, availableHeight / spanY);
      const targetZoom = targetScale / CONFIG.scale;

      CONFIG.zoom = Math.max(CONFIG.minZoom, Math.min(CONFIG.maxZoom, targetZoom));

      const isoCenterX = (minIsoX + maxIsoX) / 2;
      const isoCenterY = (minIsoY + maxIsoY) / 2;
      const effectiveScale = CONFIG.scale * CONFIG.zoom;
      CONFIG.panX = -isoCenterX * effectiveScale;
      CONFIG.panY = -isoCenterY * effectiveScale;

      updateZoomIndicator();
      redrawScene();
      return true;
    }

    function maybeAutoFit() {
      if (!state.autoFitEnabled || state.isPanning) return;
      const bounds = getLocalBounds();
      if (!bounds) return;

      const round = (value) => Math.round(value * 10) / 10;
      const signature = [
        round(bounds.minX),
        round(bounds.maxX),
        round(bounds.minY),
        round(bounds.maxY),
        round(bounds.minZ),
        round(bounds.maxZ)
      ].join('|');

      if (signature === state.lastFitSignature) return;
      state.lastFitSignature = signature;
      fitToMapView(bounds);
    }

    function renderDock() {
      // Remove existing dock marker before re-rendering
      const existingDock = groundLayer.querySelector('.dock-marker');
      if (existingDock) existingDock.remove();

      const pos = toIsometric(0, 0, 0);
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('class', 'dock-marker');

      // Base platform (isometric rectangle)
      const size = 8;
      const p1 = toIsometric(-size, -size);
      const p2 = toIsometric(size, -size);
      const p3 = toIsometric(size, size);
      const p4 = toIsometric(-size, size);
      const basePath = `M${p1.screenX},${p1.screenY} L${p2.screenX},${p2.screenY} L${p3.screenX},${p3.screenY} L${p4.screenX},${p4.screenY} Z`;

      const base = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      base.setAttribute('d', basePath);
      base.setAttribute('class', 'dock-base');
      g.appendChild(base);

      // Landing pad circle
      const pad = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
      pad.setAttribute('cx', pos.screenX);
      pad.setAttribute('cy', pos.screenY);
      pad.setAttribute('rx', size * CONFIG.scale * 0.6);
      pad.setAttribute('ry', size * CONFIG.scale * 0.3);
      pad.setAttribute('class', 'dock-pad');
      g.appendChild(pad);

      // Label
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', pos.screenX);
      label.setAttribute('y', pos.screenY + size * CONFIG.scale + 15);
      label.setAttribute('class', 'dock-label');
      label.textContent = 'DOCK';
      g.appendChild(label);

      groundLayer.appendChild(g);
    }

    function renderMapCube(preview, status) {
      mapLayer.innerHTML = '';
      if (!preview || !preview.bounds) return;

      const bounds = preview.bounds;
      const width = Math.max(10, bounds.max_x - bounds.min_x);
      const depth = Math.max(10, bounds.max_y - bounds.min_y);
      const scale = CONFIG.mapScale;
      const halfX = (width / 2) * scale;
      const halfY = (depth / 2) * scale;
      const height = Math.max(8, CONFIG.mapHeightM * scale);

      const centerX = CONFIG.mapOffsetX;
      const centerY = CONFIG.mapOffsetY;
      const midX = (bounds.min_x + bounds.max_x) / 2;
      const midY = (bounds.min_y + bounds.max_y) / 2;
      const rangeX = Math.max(1, bounds.max_x - bounds.min_x);
      const rangeY = Math.max(1, bounds.max_y - bounds.min_y);

      const corners = [
        { x: centerX - halfX, y: centerY - halfY, z: 0 },
        { x: centerX + halfX, y: centerY - halfY, z: 0 },
        { x: centerX + halfX, y: centerY + halfY, z: 0 },
        { x: centerX - halfX, y: centerY + halfY, z: 0 },
        { x: centerX - halfX, y: centerY - halfY, z: height },
        { x: centerX + halfX, y: centerY - halfY, z: height },
        { x: centerX + halfX, y: centerY + halfY, z: height },
        { x: centerX - halfX, y: centerY + halfY, z: height }
      ];

      const iso = corners.map(c => toIsometric(c.x, c.y, c.z));
      const topFace = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      topFace.setAttribute(
        'd',
        `M${iso[4].screenX},${iso[4].screenY} L${iso[5].screenX},${iso[5].screenY} ` +
          `L${iso[6].screenX},${iso[6].screenY} L${iso[7].screenX},${iso[7].screenY} Z`
      );
      topFace.setAttribute('class', 'map-cube-face');
      mapLayer.appendChild(topFace);

      const edges = [
        [0, 1], [1, 2], [2, 3], [3, 0],
        [4, 5], [5, 6], [6, 7], [7, 4],
        [0, 4], [1, 5], [2, 6], [3, 7]
      ];
      edges.forEach(([a, b]) => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', iso[a].screenX);
        line.setAttribute('y1', iso[a].screenY);
        line.setAttribute('x2', iso[b].screenX);
        line.setAttribute('y2', iso[b].screenY);
        line.setAttribute('class', 'map-cube-line');
        mapLayer.appendChild(line);
      });

      if (preview.obstacles && preview.obstacles.length) {
        preview.obstacles.slice(0, 60).forEach(obs => {
          const localX = ((obs.x - midX) / (rangeX / 2)) * halfX;
          const localY = ((obs.y - midY) / (rangeY / 2)) * halfY;
          const pointPos = toIsometric(centerX + localX, centerY + localY, height * 0.6);
          const dot = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          dot.setAttribute('cx', pointPos.screenX);
          dot.setAttribute('cy', pointPos.screenY);
          dot.setAttribute('r', '2.2');
          dot.setAttribute('class', 'map-cube-point');
          mapLayer.appendChild(dot);
        });
      }

      const labelPos = toIsometric(centerX, centerY, height + 6);
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', labelPos.screenX);
      label.setAttribute('y', labelPos.screenY);
      label.setAttribute('class', 'map-cube-label');
      if (status && status.map_available) {
        const age = status.map_age_s !== undefined ? `${Math.round(status.map_age_s)}s` : '--';
        const quality = status.map_quality_score !== undefined
          ? `${Math.round(status.map_quality_score * 100)}%`
          : '--';
        label.textContent = `SLAM MAP ¬∑ ${age} ¬∑ ${quality}`;
      } else {
        label.textContent = 'SLAM MAP';
      }
      mapLayer.appendChild(label);
    }

    // SLAM obstacle colors by type
    const OBSTACLE_COLORS = {
      building: '#ef4444', building_tall: '#dc2626', tower: '#b91c1c',
      tree: '#22c55e', structure_low: '#f97316', ground_obstacle: '#eab308',
      house: '#f59e0b', warehouse: '#d97706', solar_panel: '#3b82f6',
      substation: '#8b5cf6', power_line: '#ec4899', wind_turbine: '#06b6d4',
      unknown: '#6b7280'
    };

    // Helper for heatmap color (height-based gradient)
    function getHeatmapColor(height, minH, maxH) {
      const t = Math.min(1, Math.max(0, (height - minH) / (maxH - minH || 1)));
      // Blue -> Cyan -> Green -> Yellow -> Red gradient
      if (t < 0.25) {
        const s = t / 0.25;
        return `rgb(${Math.round(0 + s * 0)}, ${Math.round(128 + s * 127)}, ${Math.round(255 - s * 55)})`;
      } else if (t < 0.5) {
        const s = (t - 0.25) / 0.25;
        return `rgb(${Math.round(0 + s * 100)}, ${Math.round(255 - s * 55)}, ${Math.round(200 - s * 100)})`;
      } else if (t < 0.75) {
        const s = (t - 0.5) / 0.25;
        return `rgb(${Math.round(100 + s * 155)}, ${Math.round(200 - s * 50)}, ${Math.round(100 - s * 100)})`;
      } else {
        const s = (t - 0.75) / 0.25;
        return `rgb(255, ${Math.round(150 - s * 150)}, 0)`;
      }
    }

    function renderSlamObstacles() {
      // Clear existing obstacle elements
      const existingObstacles = mapLayer.querySelectorAll('.slam-obstacle');
      existingObstacles.forEach(el => el.remove());

      // Check if obstacles should be shown
      if (!slamConfig.showObstacles) return;
      if (!state.slamObstacles || state.slamObstacles.length === 0) return;

      state.slamObstacles.forEach(obs => {
        // SLAM data is in NED frame: x_ned=North, y_ned=East
        // Overlay local coords: x=East, y=-North (South positive)
        const nedX = obs.x ?? obs.x_ned ?? 0;  // North
        const nedY = obs.y ?? obs.y_ned ?? 0;  // East
        // Apply offset and coordinate transformation
        const localX = nedY + slamConfig.offsetX;   // East maps to overlay X + offset
        const localY = -nedX + slamConfig.offsetY;  // -North (South) maps to overlay Y + offset

        const r = obs.r ?? obs.radius_m ?? 3;
        const h = obs.h ?? obs.height_m ?? 5;

        // Apply height filtering
        if (h < slamConfig.heightMin || h > slamConfig.heightMax) return;

        const type = obs.type ?? obs.obstacle_type ?? 'unknown';
        // Use heatmap color if enabled, otherwise use type-based color
        const color = slamConfig.heatmapMode
          ? getHeatmapColor(h, slamConfig.heightMin, slamConfig.heightMax)
          : (OBSTACLE_COLORS[type] || OBSTACLE_COLORS.unknown);

        const pos = toIsometric(localX, localY, 0);
        const topPos = toIsometric(localX, localY, h);
        const effectiveScale = CONFIG.scale * CONFIG.zoom;
        const screenRadius = Math.max(3, r * effectiveScale * 0.5);

        const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
        g.setAttribute('class', 'slam-obstacle');

        // Base circle
        const base = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
        base.setAttribute('cx', pos.screenX);
        base.setAttribute('cy', pos.screenY);
        base.setAttribute('rx', screenRadius);
        base.setAttribute('ry', screenRadius * 0.5);
        base.setAttribute('fill', color);
        base.setAttribute('fill-opacity', String(slamConfig.opacity * 0.6));
        base.setAttribute('stroke', color);
        base.setAttribute('stroke-width', '1');
        g.appendChild(base);

        // Vertical line for height indicator
        if (h > 2) {
          const vline = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          vline.setAttribute('x1', pos.screenX);
          vline.setAttribute('y1', pos.screenY);
          vline.setAttribute('x2', topPos.screenX);
          vline.setAttribute('y2', topPos.screenY);
          vline.setAttribute('stroke', color);
          vline.setAttribute('stroke-width', '2');
          vline.setAttribute('stroke-opacity', String(slamConfig.opacity * 0.85));
          g.appendChild(vline);

          // Top marker
          const top = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          top.setAttribute('cx', topPos.screenX);
          top.setAttribute('cy', topPos.screenY);
          top.setAttribute('r', Math.max(2, screenRadius * 0.4));
          top.setAttribute('fill', color);
          g.appendChild(top);
        }

        mapLayer.appendChild(g);
      });
    }

    function renderSplatPoints() {
      const existingPoints = mapLayer.querySelectorAll('.splat-point');
      existingPoints.forEach(el => el.remove());

      // Check if points should be shown
      if (!slamConfig.showPoints) return;

      const points = state.splatPoints.length > 0 ? state.splatPoints : state.previewPoints;
      if (!points || points.length === 0) return;

      // Limit rendering for performance (show every Nth point at low zoom)
      const stride = CONFIG.zoom < 0.5 ? 5 : CONFIG.zoom < 1 ? 3 : 1;
      const pointRadius = Math.max(1, slamConfig.pointSize * 0.5 * CONFIG.zoom);

      for (let i = 0; i < points.length; i += stride) {
        const pt = points[i];
        const height = pt.z || 0;

        // Apply height filtering (z is typically negative for altitude in NED)
        const absHeight = Math.abs(height);
        if (absHeight < slamConfig.heightMin || absHeight > slamConfig.heightMax) continue;

        // Splat points are typically in NED frame from AirSim
        // Convert: NED x=North, y=East -> Overlay x=East, y=-North
        // Apply offset for alignment with drone positions
        const localX = pt.y + slamConfig.offsetX;   // East + offset
        const localY = -pt.x + slamConfig.offsetY;  // -North + offset
        const pos = toIsometric(localX, localY, height);

        // Determine color: heatmap or original RGB
        let fill;
        if (slamConfig.heatmapMode) {
          fill = getHeatmapColor(absHeight, slamConfig.heightMin, slamConfig.heightMax);
        } else {
          fill = `rgb(${pt.r || 128}, ${pt.g || 128}, ${pt.b || 128})`;
        }

        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        circle.setAttribute('class', 'splat-point');
        circle.setAttribute('cx', pos.screenX);
        circle.setAttribute('cy', pos.screenY);
        circle.setAttribute('r', pointRadius);
        circle.setAttribute('fill', fill);
        circle.setAttribute('fill-opacity', String(slamConfig.opacity));
        mapLayer.appendChild(circle);
      }
    }

    function renderTarget() {
      const existingTarget = mapLayer.querySelectorAll('.target-marker');
      existingTarget.forEach(el => el.remove());

      if (!state.target) return;

      const target = state.target;
      const x = target.x ?? 0;
      const y = target.y ?? 0;
      const z = target.z ?? 0;
      const pos = toIsometric(x, y, z);

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('class', 'target-marker');

      // Pulsing target rings
      const ringOuter = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      ringOuter.setAttribute('cx', pos.screenX);
      ringOuter.setAttribute('cy', pos.screenY);
      ringOuter.setAttribute('r', 20 * CONFIG.zoom);
      ringOuter.setAttribute('fill', 'none');
      ringOuter.setAttribute('stroke', '#f59e0b');
      ringOuter.setAttribute('stroke-width', '2');
      ringOuter.setAttribute('class', 'target-ring-pulse');
      g.appendChild(ringOuter);

      const ringMid = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      ringMid.setAttribute('cx', pos.screenX);
      ringMid.setAttribute('cy', pos.screenY);
      ringMid.setAttribute('r', 12 * CONFIG.zoom);
      ringMid.setAttribute('fill', 'none');
      ringMid.setAttribute('stroke', '#f59e0b');
      ringMid.setAttribute('stroke-width', '2');
      g.appendChild(ringMid);

      const ringInner = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      ringInner.setAttribute('cx', pos.screenX);
      ringInner.setAttribute('cy', pos.screenY);
      ringInner.setAttribute('r', 5 * CONFIG.zoom);
      ringInner.setAttribute('fill', '#f59e0b');
      g.appendChild(ringInner);

      // Crosshair lines
      const lineLen = 30 * CONFIG.zoom;
      [{ dx: -lineLen, dy: 0 }, { dx: lineLen, dy: 0 }, { dx: 0, dy: -lineLen }, { dx: 0, dy: lineLen }].forEach(offset => {
        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.setAttribute('x1', pos.screenX);
        line.setAttribute('y1', pos.screenY);
        line.setAttribute('x2', pos.screenX + offset.dx);
        line.setAttribute('y2', pos.screenY + offset.dy);
        line.setAttribute('stroke', '#f59e0b');
        line.setAttribute('stroke-width', '1.5');
        line.setAttribute('stroke-dasharray', '4,2');
        g.appendChild(line);
      });

      // Target label
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', pos.screenX);
      label.setAttribute('y', pos.screenY - 30 * CONFIG.zoom);
      label.setAttribute('text-anchor', 'middle');
      label.setAttribute('fill', '#f59e0b');
      label.setAttribute('font-size', `${10 * CONFIG.zoom}px`);
      label.setAttribute('font-weight', 'bold');
      label.textContent = target.name || 'TARGET';
      g.appendChild(label);

      mapLayer.appendChild(g);

      // Update target info display
      updateTargetInfo();
    }

    function updateTargetInfo() {
      // Use the selected drone from camera state, or first drone as fallback
      const selectedId = cameraState.selectedDroneId;
      if (selectedId) {
        updateTargetInfoForDrone(selectedId);
      } else if (state.drones.size > 0) {
        const firstDroneId = Array.from(state.drones.keys())[0];
        updateTargetInfoForDrone(firstDroneId);
      } else {
        // No drones, hide target info
        const targetInfo = document.getElementById('targetInfo');
        if (targetInfo) targetInfo.style.display = 'none';
      }
    }

    function updateTargetInfoForDrone(droneId) {
      const targetInfo = document.getElementById('targetInfo');
      if (!targetInfo) return;

      const drone = state.drones.get(droneId);
      if (!drone || !drone.data) {
        targetInfo.style.display = 'none';
        return;
      }

      // Use drone's current target, fall back to global state.target
      const target = drone.data.target || state.target;
      if (!target) {
        targetInfo.style.display = 'none';
        return;
      }

      targetInfo.style.display = 'block';

      // Helper to check if a value is a valid number
      const isValidNum = (v) => v != null && !Number.isNaN(v) && Number.isFinite(v);

      // Calculate delta from this specific drone to its target
      let delta = '--';
      let deltaM = 0;
      const droneX = isValidNum(drone.data.localX) ? drone.data.localX : 0;
      const droneY = isValidNum(drone.data.localY) ? drone.data.localY : 0;

      // Get target coordinates - try from target object, or look up asset
      let targetX = target.x;
      let targetY = target.y;

      // If target doesn't have coords, try to get from asset state
      if (!isValidNum(targetX) || !isValidNum(targetY)) {
        if (target.assetId) {
          const assetData = state.assets.get(target.assetId);
          if (assetData && assetData.data) {
            targetX = assetData.data.localX;
            targetY = assetData.data.localY;
            // Update target with found coords
            target.x = targetX;
            target.y = targetY;
            target.lat = assetData.data.lat;
            target.lon = assetData.data.lon;
          }
        }
      }

      if (isValidNum(targetX) && isValidNum(targetY)) {
        const dx = targetX - droneX;
        const dy = targetY - droneY;
        deltaM = Math.sqrt(dx * dx + dy * dy);
        if (isValidNum(deltaM)) {
          delta = deltaM.toFixed(0) + 'm';
        }
      }

      document.getElementById('targetName').textContent = target.name || 'Target';

      // Display coordinates in separate X/Y fields
      const hasValidLocal = isValidNum(target.x) && isValidNum(target.y);
      const targetXEl = document.getElementById('targetX');
      const targetYEl = document.getElementById('targetY');
      if (targetXEl && targetYEl) {
        if (hasValidLocal) {
          targetXEl.textContent = target.x.toFixed(1);
          targetYEl.textContent = target.y.toFixed(1);
        } else {
          targetXEl.textContent = '--';
          targetYEl.textContent = '--';
        }
      }

      // Update distance with color coding
      const deltaEl = document.getElementById('targetDelta');
      if (deltaEl) {
        deltaEl.textContent = delta;
        deltaEl.classList.remove('close', 'far');
        if (isValidNum(deltaM)) {
          if (deltaM < 20) {
            deltaEl.classList.add('close');
          } else if (deltaM > 100) {
            deltaEl.classList.add('far');
          }
        }
      }
    }

    function updateAssetPosition(asset) {
      if (!asset.element || !asset.data) return;
      // Assets are re-rendered on redraw, no need for incremental update
    }

    function updateDroneVisualPosition(droneId, lat, lon, alt) {
      const drone = state.drones.get(droneId);
      if (!drone || !drone.element) return;

      const local = gpsToLocal(lat, lon);
      const pos = toIsometric(local.x, local.y, alt);

      // Store local coordinates for delta calculation
      drone.data = drone.data || {};
      drone.data.lat = lat;
      drone.data.lon = lon;
      drone.data.alt = alt;
      drone.data.localX = local.x;
      drone.data.localY = local.y;

      // Update element positions
      const body = drone.element.querySelector('.drone-body');
      if (body) {
        const headingRad = (drone.data.heading || 0) * Math.PI / 180;
        const tipLen = 8;
        const wingSpan = 6;
        const tipX = pos.screenX + Math.sin(headingRad) * tipLen;
        const tipY = pos.screenY - Math.cos(headingRad) * tipLen;
        const leftX = pos.screenX + Math.sin(headingRad + 2.5) * wingSpan;
        const leftY = pos.screenY - Math.cos(headingRad + 2.5) * wingSpan;
        const rightX = pos.screenX + Math.sin(headingRad - 2.5) * wingSpan;
        const rightY = pos.screenY - Math.cos(headingRad - 2.5) * wingSpan;
        body.setAttribute('points', `${tipX},${tipY} ${leftX},${leftY} ${rightX},${rightY}`);
      }

      const shadow = drone.element.querySelector('.drone-shadow');
      if (shadow) {
        const groundPos = toIsometric(local.x, local.y, 0);
        shadow.setAttribute('cx', groundPos.screenX);
        shadow.setAttribute('cy', groundPos.screenY);
      }

      const label = drone.element.querySelector('.drone-label');
      if (label) {
        label.setAttribute('x', pos.screenX);
        label.setAttribute('y', pos.screenY + 20);
      }

      const indicator = drone.indicator;
      if (indicator) {
        indicator.setAttribute('transform', `translate(${pos.screenX + 15}, ${pos.screenY - 15})`);
      }

      updateTargetInfo();
    }

    function renderAsset(asset) {
      // Handle both HTTP format (position.latitude) and WebSocket format (top-level latitude)
      const lat = asset.latitude ?? asset.position?.latitude;
      const lon = asset.longitude ?? asset.position?.longitude;
      const local = gpsToLocal(lat, lon);
      const basePos = toIsometric(local.x, local.y, 0);
      const topPos = toIsometric(local.x, local.y, asset.altitude_m || 10);

      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('class', 'asset-group');
      g.setAttribute('data-asset-id', asset.asset_id);

      const assetType = (asset.asset_type || 'solar').toLowerCase();
      let typeClass = 'solar';
      if (assetType.includes('substation')) typeClass = 'substation';
      else if (assetType.includes('turbine') || assetType.includes('wind')) typeClass = 'turbine';

      // Different shapes based on type
      const size = 12;
      if (typeClass === 'substation') {
        // Cube-ish box
        const h = 15;
        const top = toIsometric(local.x, local.y, h);
        const corners = [
          toIsometric(local.x - size, local.y - size, 0),
          toIsometric(local.x + size, local.y - size, 0),
          toIsometric(local.x + size, local.y + size, 0),
          toIsometric(local.x - size, local.y + size, 0),
          toIsometric(local.x - size, local.y - size, h),
          toIsometric(local.x + size, local.y - size, h),
          toIsometric(local.x + size, local.y + size, h),
          toIsometric(local.x - size, local.y + size, h)
        ];
        // Front face
        const front = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        front.setAttribute('d', `M${corners[1].screenX},${corners[1].screenY} L${corners[2].screenX},${corners[2].screenY} L${corners[6].screenX},${corners[6].screenY} L${corners[5].screenX},${corners[5].screenY} Z`);
        front.setAttribute('class', `asset-base ${typeClass}`);
        g.appendChild(front);
        // Side face
        const side = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        side.setAttribute('d', `M${corners[2].screenX},${corners[2].screenY} L${corners[3].screenX},${corners[3].screenY} L${corners[7].screenX},${corners[7].screenY} L${corners[6].screenX},${corners[6].screenY} Z`);
        side.setAttribute('class', `asset-base ${typeClass}`);
        side.style.opacity = '0.7';
        g.appendChild(side);
        // Top face
        const topFace = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        topFace.setAttribute('d', `M${corners[4].screenX},${corners[4].screenY} L${corners[5].screenX},${corners[5].screenY} L${corners[6].screenX},${corners[6].screenY} L${corners[7].screenX},${corners[7].screenY} Z`);
        topFace.setAttribute('class', `asset-top ${typeClass}`);
        topFace.style.fill = 'rgba(245, 158, 11, 0.4)';
        topFace.style.stroke = '#f59e0b';
        g.appendChild(topFace);
      } else {
        // Flat panel (solar) or tall rect (turbine)
        const h = typeClass === 'turbine' ? 25 : 3;
        const w = typeClass === 'turbine' ? 4 : size;
        const corners = [
          toIsometric(local.x - w, local.y - w, 0),
          toIsometric(local.x + w, local.y - w, 0),
          toIsometric(local.x + w, local.y + w, 0),
          toIsometric(local.x - w, local.y + w, 0),
          toIsometric(local.x - w, local.y - w, h),
          toIsometric(local.x + w, local.y - w, h),
          toIsometric(local.x + w, local.y + w, h),
          toIsometric(local.x - w, local.y + w, h)
        ];
        // Top face for panel
        const topFace = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        topFace.setAttribute('d', `M${corners[4].screenX},${corners[4].screenY} L${corners[5].screenX},${corners[5].screenY} L${corners[6].screenX},${corners[6].screenY} L${corners[7].screenX},${corners[7].screenY} Z`);
        topFace.setAttribute('class', `asset-base ${typeClass}`);
        g.appendChild(topFace);

        if (typeClass === 'turbine') {
          // Vertical line for turbine
          const stem = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          const bottom = toIsometric(local.x, local.y, 0);
          const top = toIsometric(local.x, local.y, h);
          stem.setAttribute('x1', bottom.screenX);
          stem.setAttribute('y1', bottom.screenY);
          stem.setAttribute('x2', top.screenX);
          stem.setAttribute('y2', top.screenY);
          stem.setAttribute('stroke', '#8b5cf6');
          stem.setAttribute('stroke-width', '3');
          g.appendChild(stem);
        }
      }

      // Anomaly indicator
      if (asset.has_anomaly) {
        const anomaly = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
        const anomalyPos = toIsometric(local.x, local.y, 20);
        anomaly.setAttribute('cx', anomalyPos.screenX);
        anomaly.setAttribute('cy', anomalyPos.screenY);
        anomaly.setAttribute('r', '6');
        anomaly.setAttribute('class', 'asset-anomaly');
        g.appendChild(anomaly);
      }

      // Label
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      const labelPos = toIsometric(local.x, local.y, -8);
      label.setAttribute('x', labelPos.screenX);
      label.setAttribute('y', labelPos.screenY);
      label.setAttribute('class', 'asset-label');
      label.textContent = asset.name || asset.asset_id;
      g.appendChild(label);

      assetLayer.appendChild(g);
      // Store asset with local coordinates for distance calculations
      const assetData = {
        ...asset,
        localX: local.x,
        localY: local.y,
        lat: lat,
        lon: lon,
        alt: asset.altitude_m || 10,
        name: asset.name || asset.asset_id
      };
      state.assets.set(asset.asset_id, { data: assetData, element: g });
    }

    function renderDrone(drone) {
      const droneId = drone.drone_id || drone.droneId;
      // Handle both HTTP format (position.latitude) and WebSocket format (top-level latitude)
      const lat = drone.latitude ?? drone.position?.latitude ?? CONFIG.dockLat;
      const lon = drone.longitude ?? drone.position?.longitude ?? CONFIG.dockLon;
      const alt = drone.altitude_agl ?? drone.position?.altitude_agl ?? 0;

      const local = gpsToLocal(lat, lon);
      const pos = toIsometric(local.x, local.y, alt);
      const shadowPos = toIsometric(local.x, local.y, 0);

      // Create drone group
      const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      g.setAttribute('class', 'drone-group');
      g.setAttribute('data-drone-id', droneId);

      // Shadow
      const shadow = document.createElementNS('http://www.w3.org/2000/svg', 'ellipse');
      shadow.setAttribute('cx', shadowPos.screenX);
      shadow.setAttribute('cy', shadowPos.screenY);
      shadow.setAttribute('rx', 8);
      shadow.setAttribute('ry', 4);
      shadow.setAttribute('class', 'drone-shadow');
      g.appendChild(shadow);

      // Drone body (triangle pointing in heading direction)
      const droneBody = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
      const s = 8;
      droneBody.setAttribute('points', `${pos.screenX},${pos.screenY - s} ${pos.screenX - s*0.7},${pos.screenY + s*0.5} ${pos.screenX + s*0.7},${pos.screenY + s*0.5}`);
      droneBody.setAttribute('class', 'drone-body');
      g.appendChild(droneBody);

      // Cognitive state indicator
      const indicator = document.createElementNS('http://www.w3.org/2000/svg', 'g');
      indicator.setAttribute('class', 'drone-indicator');
      indicator.setAttribute('transform', `translate(${pos.screenX + 15}, ${pos.screenY - 15})`);

      const ring = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      ring.setAttribute('cx', 0);
      ring.setAttribute('cy', 0);
      ring.setAttribute('r', 10);
      ring.setAttribute('class', 'indicator-ring deliberative');
      indicator.appendChild(ring);

      const core = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      core.setAttribute('cx', 0);
      core.setAttribute('cy', 0);
      core.setAttribute('r', 6);
      core.setAttribute('class', 'indicator-core deliberative');
      indicator.appendChild(core);

      const pulse = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
      pulse.setAttribute('cx', 0);
      pulse.setAttribute('cy', 0);
      pulse.setAttribute('r', 8);
      pulse.setAttribute('class', 'indicator-pulse deliberative');
      indicator.appendChild(pulse);

      g.appendChild(indicator);

      // Label
      const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
      label.setAttribute('x', pos.screenX);
      label.setAttribute('y', pos.screenY + 20);
      label.setAttribute('class', 'drone-label');
      label.textContent = droneId;
      g.appendChild(label);

      // Click handler for expanding thought bubble
      g.addEventListener('click', () => toggleDroneBubble(droneId));

      droneLayer.appendChild(g);

      // Trail path
      const trail = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      trail.setAttribute('class', 'drone-trail');
      trail.setAttribute('d', '');
      trailLayer.appendChild(trail);

      // Create thought bubble
      const bubble = createThoughtBubble(droneId);
      thoughtBubbles.appendChild(bubble);

      state.drones.set(droneId, {
        data: { ...drone, positions: [{ x: local.x, y: local.y, z: alt }] },
        element: g,
        shadow,
        body: droneBody,
        indicator,
        ring,
        core,
        pulse,
        label,
        trail,
        bubble,
        timeout: null,
        thinking: false
      });

      // Update camera drone selector tabs
      renderDroneCameraTabs();
    }

    function updateDronePosition(droneId, lat, lon, alt) {
      const drone = state.drones.get(droneId);
      if (!drone) return;

      const local = gpsToLocal(lat, lon);
      const pos = toIsometric(local.x, local.y, alt);
      const shadowPos = toIsometric(local.x, local.y, 0);

      // Update shadow
      drone.shadow.setAttribute('cx', shadowPos.screenX);
      drone.shadow.setAttribute('cy', shadowPos.screenY);

      // Update body
      const s = 8;
      drone.body.setAttribute('points', `${pos.screenX},${pos.screenY - s} ${pos.screenX - s*0.7},${pos.screenY + s*0.5} ${pos.screenX + s*0.7},${pos.screenY + s*0.5}`);

      // Update indicator position
      drone.indicator.setAttribute('transform', `translate(${pos.screenX + 15}, ${pos.screenY - 15})`);

      // Update label
      drone.label.setAttribute('x', pos.screenX);
      drone.label.setAttribute('y', pos.screenY + 20);

      // Update trail
      drone.data.positions.push({ x: local.x, y: local.y, z: alt });
      if (drone.data.positions.length > 20) drone.data.positions.shift();

      const trailPoints = drone.data.positions.map(p => {
        const tp = toIsometric(p.x, p.y, p.z);
        return `${tp.screenX},${tp.screenY}`;
      });
      drone.trail.setAttribute('d', 'M' + trailPoints.join(' L'));

      // Update bubble position if visible
      if (drone.bubble.classList.contains('visible')) {
        positionBubble(droneId, pos.screenX, pos.screenY);
      }

      drone.data.latitude = lat;
      drone.data.longitude = lon;
      drone.data.altitude_agl = alt;
    }

    // ========== THOUGHT BUBBLE ==========
    function createThoughtBubble(droneId) {
      const bubble = document.createElement('div');
      bubble.className = 'thought-bubble';
      bubble.dataset.droneId = droneId;
      bubble.innerHTML = `
        <div class="bubble-header">
          <div class="drone-id">
            <span class="drone-icon">üöÅ</span>
            <span class="drone-name">${droneId}</span>
          </div>
          <div style="display: flex; align-items: center;">
            <span class="cognitive-badge deliberative">Thinking</span>
            <button class="bubble-toggle" title="Collapse/Expand">‚ñº</button>
          </div>
        </div>
        <div class="bubble-body">
          <div class="goal-section">
            <div class="goal-label">Current Goal</div>
            <div class="goal-text">Evaluating...</div>
            <div class="goal-target"></div>
          </div>
          <div class="risk-section">
            <div class="risk-header">
              <span class="risk-label">Risk Level</span>
              <span class="risk-value low">0%</span>
            </div>
            <div class="risk-bar">
              <div class="risk-fill low" style="width: 0%"></div>
            </div>
          </div>
          <div class="critics-section">
            <div class="critic-badge pending" data-critic="safety">
              <span class="critic-icon">üõ°Ô∏è</span>
              <span class="critic-name">Safety</span>
            </div>
            <div class="critic-badge pending" data-critic="efficiency">
              <span class="critic-icon">‚ö°</span>
              <span class="critic-name">Efficiency</span>
            </div>
            <div class="critic-badge pending" data-critic="goal_alignment">
              <span class="critic-icon">üéØ</span>
              <span class="critic-name">Goal</span>
            </div>
          </div>
          <div class="reasoning-section">
            <div class="reasoning-label">Reasoning</div>
            <ul class="reasoning-list">
              <li class="reasoning-item">Analyzing situation...</li>
            </ul>
          </div>
          <div class="decision-section">
            <div class="decision-header">
              <span class="decision-icon">‚úàÔ∏è</span>
              <span class="decision-action">DECIDING</span>
              <span class="decision-confidence">--</span>
            </div>
            <div class="decision-reasoning"></div>
          </div>
        </div>
      `;

      // Add toggle button handler
      bubble.querySelector('.bubble-toggle').addEventListener('click', (e) => {
        e.stopPropagation();
        bubble.classList.toggle('collapsed');
        updateConnectorLine(droneId);
      });

      // Add drag functionality
      setupBubbleDrag(bubble, droneId);

      return bubble;
    }

    function positionBubble(droneId, screenX, screenY) {
      const drone = state.drones.get(droneId);
      if (!drone) return;

      const bubble = drone.bubble;
      const rect = bubble.getBoundingClientRect();
      const containerRect = document.getElementById('sceneContainer').getBoundingClientRect();

      let left = screenX - 24;
      let top = screenY - rect.height - 20;

      // Keep within bounds
      if (left < 10) left = 10;
      if (left + rect.width > containerRect.width - 10) left = containerRect.width - rect.width - 10;
      if (top < 10) top = screenY + 30; // Flip below if too high

      bubble.style.left = left + 'px';
      bubble.style.top = top + 'px';

      // Update connector line
      updateConnectorLine(droneId);
    }

    // ========== BUBBLE DRAG & CONNECTOR ==========
    function setupBubbleDrag(bubble, droneId) {
      let isDragging = false;
      let startX, startY, startLeft, startTop;

      const header = bubble.querySelector('.bubble-header');

      header.addEventListener('mousedown', (e) => {
        if (e.target.classList.contains('bubble-toggle')) return;
        isDragging = true;
        bubble.classList.add('dragging');
        startX = e.clientX;
        startY = e.clientY;
        startLeft = parseInt(bubble.style.left) || 0;
        startTop = parseInt(bubble.style.top) || 0;
        e.preventDefault();
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        const dx = e.clientX - startX;
        const dy = e.clientY - startY;
        bubble.style.left = (startLeft + dx) + 'px';
        bubble.style.top = (startTop + dy) + 'px';

        // Store custom offset so it persists
        const drone = state.drones.get(droneId);
        if (drone) {
          drone.bubbleOffset = { x: startLeft + dx, y: startTop + dy, custom: true };
        }

        updateConnectorLine(droneId);
      });

      document.addEventListener('mouseup', () => {
        if (isDragging) {
          isDragging = false;
          bubble.classList.remove('dragging');
        }
      });
    }

    function updateConnectorLine(droneId) {
      const drone = state.drones.get(droneId);
      if (!drone || !drone.bubble.classList.contains('visible')) {
        // Remove connector if bubble not visible
        const existing = document.getElementById(`connector-${droneId}`);
        if (existing) existing.remove();
        return;
      }

      const connectorLayer = document.getElementById('connectorLayer');
      let line = document.getElementById(`connector-${droneId}`);

      if (!line) {
        line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
        line.id = `connector-${droneId}`;
        line.classList.add('bubble-connector');
        connectorLayer.appendChild(line);
      }

      // Get drone position in scene
      const local = gpsToLocal(drone.data.latitude || CONFIG.dockLat, drone.data.longitude || CONFIG.dockLon);
      const dronePos = toIsometric(local.x, local.y, drone.data.altitude_agl || 0);

      // Get bubble center position
      const bubble = drone.bubble;
      const bubbleRect = bubble.getBoundingClientRect();
      const containerRect = document.getElementById('sceneContainer').getBoundingClientRect();

      const bubbleX = bubbleRect.left - containerRect.left + bubbleRect.width / 2;
      const bubbleY = bubbleRect.bottom - containerRect.top;

      line.setAttribute('x1', dronePos.screenX);
      line.setAttribute('y1', dronePos.screenY);
      line.setAttribute('x2', bubbleX);
      line.setAttribute('y2', bubbleY);
    }

    function toggleDroneBubble(droneId) {
      const drone = state.drones.get(droneId);
      if (!drone) return;

      if (state.expandedDroneId === droneId) {
        // Collapse
        drone.bubble.classList.remove('visible');
        state.expandedDroneId = null;
        updateConnectorLine(droneId); // Remove connector
      } else {
        // Collapse previous and remove its connector
        if (state.expandedDroneId) {
          const prev = state.drones.get(state.expandedDroneId);
          if (prev) {
            prev.bubble.classList.remove('visible');
            updateConnectorLine(state.expandedDroneId);
          }
        }
        // Expand this one
        const local = gpsToLocal(drone.data.latitude || CONFIG.dockLat, drone.data.longitude || CONFIG.dockLon);
        const pos = toIsometric(local.x, local.y, drone.data.altitude_agl || 0);

        // Use custom offset if user dragged, otherwise auto-position
        if (drone.bubbleOffset && drone.bubbleOffset.custom) {
          drone.bubble.style.left = drone.bubbleOffset.x + 'px';
          drone.bubble.style.top = drone.bubbleOffset.y + 'px';
        } else {
          positionBubble(droneId, pos.screenX, pos.screenY);
        }

        drone.bubble.classList.add('visible');
        state.expandedDroneId = droneId;

        // Need small delay for bubble to render before calculating connector
        requestAnimationFrame(() => updateConnectorLine(droneId));
      }
    }

    function updateIndicatorState(droneId, level, thinking) {
      const drone = state.drones.get(droneId);
      if (!drone) return;

      const levelLower = (level || 'deliberative').toLowerCase();
      drone.ring.setAttribute('class', `indicator-ring ${levelLower}`);
      drone.core.setAttribute('class', `indicator-core ${levelLower}`);
      drone.pulse.setAttribute('class', `indicator-pulse ${levelLower} ${thinking ? 'active' : ''}`);
      drone.thinking = thinking;
    }

    // ========== WEBSOCKET HANDLERS ==========
    const ACTION_ICONS = {
      'INSPECT': 'üîç', 'ABORT': 'üõë', 'GOTO': 'üìç', 'DOCK': 'üè†',
      'RTL': '‚Ü©Ô∏è', 'WAIT': '‚è≥', 'HOVER': 'üöÅ', 'default': '‚úàÔ∏è'
    };

    function handleMessage(data) {
      // Handle both 'type' (unreal messages) and 'event_type' (Event model from connection_manager)
      const type = data.type || data.event_type;
      const droneId = data.drone_id || data.droneId || data.data?.drone_id || 'unknown';

      switch (type) {
        case 'thinking_start':
          hideEmptyState();
          handleThinkingStart(droneId, data);
          break;
        case 'thinking_update':
          hideEmptyState();
          handleThinkingUpdate(droneId, data);
          break;
        case 'thinking_complete':
          hideEmptyState();
          handleThinkingComplete(droneId, data);
          break;
        case 'critic_result':
          hideEmptyState();
          handleCriticResult(droneId, data);
          break;
        case 'risk_update':
          handleRiskUpdate(droneId, data);
          break;
        case 'airsim_telemetry':
        case 'telemetry':
          hideEmptyState();
          handleTelemetry(droneId, data);
          break;
        case 'camera_frame':
          handleCameraFrame(data);
          break;
        case 'spawn_asset':
          handleSpawnAsset(data);
          break;
        case 'battery_update':
        case 'battery_warning':
        case 'battery_critical':
          handleBatteryUpdate(data);
          break;
        case 'dock_update':
          handleDockUpdate(data);
          break;
        case 'environment_update':
          handleEnvironmentUpdate(data);
          break;
        case 'preflight_status':
          handlePreflightStatus(data);
          appendLog(
            `Preflight ${data.status || 'status'}: ${data.message || ''}`,
            data.status === 'failed' ? 'error' : data.status === 'timeout' ? 'warning' : 'info'
          );
          break;
        case 'server_decision':
          hideEmptyState();
          handleServerDecision(droneId, data);
          break;
        case 'scenario_stopped':
        case 'scenario_complete':
        case 'scenario_reset':
        case 'scenario_failed':
          handleScenarioReset();
          appendLog(`Scenario ${type.replace('scenario_', '')}: ${data.message || 'Mission ended'}`, 'info');
          break;
        case 'heartbeat':
        case 'sync':
          break;
        default:
          console.log('Unknown message:', type, data);
      }
    }

    // Reset all overlay state when scenario ends
    function handleScenarioReset() {
      // Clear all drones
      state.drones.forEach((drone, droneId) => {
        if (drone.element) drone.element.remove();
        if (drone.bubble) drone.bubble.remove();
        if (drone.connector) drone.connector.remove();
      });
      state.drones.clear();

      // Clear all assets
      state.assets.forEach((asset) => {
        if (asset.element) asset.element.remove();
      });
      state.assets.clear();

      // Clear target
      state.target = null;

      // Clear camera state
      cameraState.frames.clear();
      cameraState.selectedDroneId = null;
      cameraState.streaming = false;

      // Hide target info
      const targetInfo = document.getElementById('targetInfo');
      if (targetInfo) targetInfo.style.display = 'none';

      // Reset counters
      document.getElementById('infoDrones').textContent = '0';
      document.getElementById('infoAssets').textContent = '0';

      // Clear drone camera tabs
      droneCameraTabs.innerHTML = '';

      // Clear camera thumbnail strip
      cameraThumbnails.innerHTML = '';

      // Reset main camera view
      cameraImage.style.display = 'none';
      cameraPlaceholder.style.display = 'flex';
      cameraPlaceholder.textContent = 'Awaiting camera stream...';

      // Clear logs
      const scenarioLogList = document.getElementById('scenarioLogList');
      if (scenarioLogList) {
        scenarioLogList.innerHTML = '<div class="log-placeholder">No events yet</div>';
      }

      // Show empty state
      showEmptyState();

      appendLog('Scenario reset - all state cleared', 'info');
    }

    function handleTelemetry(droneId, data) {
      // Ensure drone exists
      if (!state.drones.has(droneId)) {
        renderDrone({ drone_id: droneId, latitude: CONFIG.dockLat, longitude: CONFIG.dockLon, altitude_agl: 0 });
      }

      // Handle position - could be GPS coords or NED position array
      let lat = CONFIG.dockLat;
      let lon = CONFIG.dockLon;
      let alt = 0;

      if (data.position) {
        if (Array.isArray(data.position)) {
          // NED position array [north, east, down]
          const north = data.position[0] || 0;
          const east = data.position[1] || 0;
          const down = data.position[2] || 0;
          lat = CONFIG.dockLat + north / 111320;
          lon = CONFIG.dockLon + east / (111320 * Math.cos(CONFIG.dockLat * Math.PI / 180));
          alt = -down; // NED down is negative altitude
        } else {
          lat = data.position.latitude ?? data.position.lat ?? CONFIG.dockLat;
          lon = data.position.longitude ?? data.position.lon ?? CONFIG.dockLon;
          alt = data.position.altitude_agl ?? data.position.alt ?? 0;
        }
      } else {
        lat = data.latitude ?? data.lat ?? CONFIG.dockLat;
        lon = data.longitude ?? data.lon ?? CONFIG.dockLon;
        alt = data.altitude_agl ?? data.alt ?? 0;
      }

      updateDronePosition(droneId, lat, lon, alt);

      // Update debug display with latest telemetry
      if (typeof updateDebugTelemetry === 'function') {
        updateDebugTelemetry(lat, lon, alt);
      }

      // Update battery display if available
      if (data.battery_percent !== undefined) {
        updateBatteryDisplay(data.battery_percent, data.landed_state);
      }
    }

    // Battery/Status display updates
    function updateBatteryDisplay(percent, landedState) {
      const baseCharging = document.getElementById('baseCharging');
      const baseDocked = document.getElementById('baseDocked');

      if (baseCharging && percent !== undefined) {
        baseCharging.textContent = `${percent.toFixed(0)}%`;
      }
      if (baseDocked && landedState !== undefined) {
        // landed_state: 0=flying, 1=landed
        baseDocked.textContent = landedState === 1 ? '1 / 1' : '0 / 1';
      }
    }

    function handleBatteryUpdate(data) {
      const baseCharging = document.getElementById('baseCharging');
      const baseDocked = document.getElementById('baseDocked');

      if (baseCharging && data.percent !== undefined) {
        const chargingIcon = data.is_charging ? '‚ö°' : '';
        baseCharging.textContent = `${chargingIcon}${data.percent.toFixed(0)}%`;
      }
      if (baseDocked && data.drone_id) {
        baseDocked.textContent = data.is_charging ? '1 / 1' : '0 / 1';
      }
    }

    function handleDockUpdate(data) {
      const baseStatus = document.getElementById('baseStatus');
      const baseDocked = document.getElementById('baseDocked');
      const baseCharging = document.getElementById('baseCharging');

      if (baseStatus) {
        const statusDot = baseStatus.querySelector('.status-dot');
        if (statusDot) {
          statusDot.classList.remove('online', 'offline', 'warning');
          statusDot.classList.add(data.status === 'available' || data.status === 'charging' ? 'online' : 'warning');
        }
        baseStatus.innerHTML = `<span class="status-dot ${data.status === 'available' || data.status === 'charging' ? 'online' : 'warning'}"></span>${data.status || 'Unknown'}`;
      }
      if (baseDocked && data.docked_drone_id) {
        baseDocked.textContent = data.docked_drone_id ? '1 / 1' : '0 / 1';
      }
      if (baseCharging && data.charge_percent !== undefined) {
        baseCharging.textContent = `${data.charge_percent.toFixed(0)}%`;
      }

      const dockLat = data.latitude ?? data.lat;
      const dockLon = data.longitude ?? data.lon;
      if (dockLat != null && dockLon != null) {
        setDockReference(dockLat, dockLon, 'dock_update', { force: true, lock: true });
      }
    }

    function handleEnvironmentUpdate(data) {
      const baseWeather = document.getElementById('baseWeather');
      const baseWind = document.getElementById('baseWind');

      if (baseWeather) {
        let weather = 'Clear';
        if (data.rain > 0.5) weather = 'Rainy';
        else if (data.fog > 0.5) weather = 'Foggy';
        else if (data.snow > 0.5) weather = 'Snow';
        else if (data.dust > 0.3) weather = 'Dusty';
        else if (data.rain > 0.1) weather = 'Light Rain';
        baseWeather.textContent = weather;
      }
      if (baseWind && data.wind_speed_ms !== undefined) {
        // Convert m/s to knots (1 m/s = 1.944 knots)
        const windKts = (data.wind_speed_ms * 1.944).toFixed(0);
        baseWind.textContent = `${windKts} kts`;
      }
    }

    // Preflight status state
    const preflightState = {
      status: 'idle',
      captureCount: 0,
      totalCaptures: 0,
      slamStatus: '--',
      mappingStatus: '--',
      quality: '--'
    };

    const PREFLIGHT_ICONS = {
      'idle': '‚è∏Ô∏è',
      'started': 'üöÄ',
      'capturing': 'üì∏',
      'processing': '‚öôÔ∏è',
      'complete': '‚úÖ',
      'failed': '‚ùå',
      'timeout': '‚è±Ô∏è',
      'skipped': '‚è≠Ô∏è',
      'retrying': 'üîÑ',
      'recovering': 'üîß',
      'recovery_failed': 'üí•'
    };

    function handlePreflightStatus(data) {
      const status = data.status || 'idle';
      const message = data.message || '';
      // Details may be nested in data.details or at top level
      const details = data.details || data;

      // Update state
      preflightState.status = status;
      if (details.capture_count !== undefined) {
        preflightState.captureCount = details.capture_count;
      }
      if (details.total_captures !== undefined) {
        preflightState.totalCaptures = details.total_captures;
      }
      if (details.slam_status !== undefined) {
        preflightState.slamStatus = details.slam_status;
      }
      if (details.mapping_status !== undefined) {
        preflightState.mappingStatus = details.mapping_status;
      }
      if (details.quality !== undefined && details.quality !== null) {
        preflightState.quality = typeof details.quality === 'number' ?
          `${(details.quality * 100).toFixed(0)}%` : details.quality;
      }

      // Update UI elements
      const statusBar = document.querySelector('.preflight-status-bar');
      const iconEl = document.getElementById('preflightIcon');
      const textEl = document.getElementById('preflightStatusText');
      const progressContainer = document.getElementById('preflightProgressContainer');
      const progressFill = document.getElementById('preflightProgressFill');
      const progressText = document.getElementById('preflightProgressText');
      const mappingEl = document.getElementById('preflightMapping');
      const capturesEl = document.getElementById('preflightCaptures');
      const slamEl = document.getElementById('preflightSlam');
      const qualityEl = document.getElementById('preflightQuality');
      const messageContainer = document.getElementById('preflightMessage');

      // Update status bar
      if (statusBar) {
        statusBar.className = 'preflight-status-bar ' + status;
      }
      if (iconEl) {
        iconEl.textContent = PREFLIGHT_ICONS[status] || '‚ùì';
      }
      if (textEl) {
        const statusLabels = {
          'idle': 'Idle',
          'started': 'Starting...',
          'capturing': 'Capturing...',
          'processing': 'Processing...',
          'complete': 'Complete',
          'failed': 'Failed',
          'timeout': 'Timeout',
          'skipped': 'Skipped',
          'retrying': 'Retrying...',
          'recovering': 'Recovering...',
          'recovery_failed': 'Recovery Failed'
        };
        textEl.textContent = statusLabels[status] || status;
      }

      // Show/hide and update progress bar
      if (progressContainer && progressFill && progressText) {
        if (status === 'capturing' && preflightState.totalCaptures > 0) {
          progressContainer.style.display = 'flex';
          const pct = Math.min(100, (preflightState.captureCount / preflightState.totalCaptures) * 100);
          progressFill.style.width = pct + '%';
          progressText.textContent = `${preflightState.captureCount}/${preflightState.totalCaptures}`;
        } else if (status === 'processing') {
          progressContainer.style.display = 'flex';
          progressFill.style.width = '100%';
          progressText.textContent = 'SLAM';
        } else if (status === 'complete' || status === 'idle') {
          progressContainer.style.display = 'none';
        }
      }

      // Update stats
      if (mappingEl) {
        mappingEl.textContent = preflightState.mappingStatus;
        mappingEl.style.color = status === 'complete' ? 'var(--accent-security)' :
                                status === 'failed' ? 'var(--accent-alert)' : '';
      }
      if (capturesEl) {
        capturesEl.textContent = preflightState.captureCount;
      }
      if (slamEl) {
        slamEl.textContent = preflightState.slamStatus;
      }
      if (qualityEl) {
        qualityEl.textContent = preflightState.quality;
      }

      // Update message
      if (messageContainer && message) {
        const msgText = messageContainer.querySelector('.preflight-message-text');
        if (msgText) msgText.textContent = message;
        messageContainer.style.display = 'block';
        messageContainer.className = 'preflight-message ' +
          (status === 'failed' ? 'error' : status === 'timeout' ? 'warning' :
           status === 'complete' ? 'success' : '');
      } else if (messageContainer && !message) {
        messageContainer.style.display = 'none';
      }
    }

    function handleServerDecision(droneId, data) {
      // Increment decision counter
      if (!state.decisionCount) state.decisionCount = 0;
      state.decisionCount++;

      // Update decision counter display
      const decisionEl = document.getElementById('decisionCount');
      if (decisionEl) {
        decisionEl.textContent = state.decisionCount;
      }

      // Log decision for debugging
      const payload = data.data || data;
      const action = payload.action || 'UNKNOWN';
      const confidence = payload.confidence || 0;
      const reason = payload.reasoning || payload.reason || '';
      console.log(`Decision #${state.decisionCount}: ${action} (${(confidence * 100).toFixed(0)}%) - ${reason.slice(0, 50)}`);

      // Trigger thinking visualization for this decision
      if (droneId && droneId !== 'unknown') {
        ensureDrone(droneId);
        const drone = state.drones.get(droneId);
        if (drone) {
          drone.data = drone.data || {};

          // Store target_asset on this drone for distance calculation
          const targetAsset = payload.target_asset || payload.targetAsset;
          if (targetAsset) {
            // Find the asset in state.assets to get its coordinates
            const assetData = state.assets.get(targetAsset.asset_id);
            if (assetData && assetData.data) {
              drone.data.target = {
                name: targetAsset.name || assetData.data.name || targetAsset.asset_id,
                assetId: targetAsset.asset_id,
                x: assetData.data.localX,
                y: assetData.data.localY,
                lat: assetData.data.lat,
                lon: assetData.data.lon,
                z: assetData.data.alt || 10
              };
            } else {
              // Asset not in state yet, store basic info
              drone.data.target = {
                name: targetAsset.name || targetAsset.asset_id,
                assetId: targetAsset.asset_id
              };
            }
            // Update target info display if this is the selected drone
            if (cameraState.selectedDroneId === droneId || !cameraState.selectedDroneId) {
              updateTargetInfoForDrone(droneId);
            }
          } else if (action === 'wait' || action === 'WAIT') {
            // Clear target for wait actions
            drone.data.target = null;
            if (cameraState.selectedDroneId === droneId || !cameraState.selectedDroneId) {
              updateTargetInfoForDrone(droneId);
            }
          }

          // Flash the decision indicator
          const bubble = drone.bubble;
          if (bubble) {
            bubble.classList.add('deciding');
            const goalText = bubble.querySelector('.goal-text');
            if (goalText) {
              goalText.textContent = formatGoal(action);
            }
            setTimeout(() => {
              bubble.classList.remove('deciding');
              bubble.classList.add('complete');
            }, 1500);
          }
        }
      }
    }

    function handleSpawnAsset(data) {
      if (!state.assets.has(data.asset_id)) {
        renderAsset(data);
      }
    }

    function handleThinkingStart(droneId, data) {
      ensureDrone(droneId);
      const drone = state.drones.get(droneId);
      const bubble = drone.bubble;

      const level = data.cognitive_level || data.cognitiveLevel || 'deliberative';
      updateIndicatorState(droneId, level, true);

      bubble.classList.remove('complete');
      bubble.classList.add('deciding');

      const badge = bubble.querySelector('.cognitive-badge');
      badge.className = `cognitive-badge ${level.toLowerCase()}`;
      badge.textContent = level.charAt(0).toUpperCase() + level.slice(1);

      if (data.current_goal || data.currentGoal) {
        bubble.querySelector('.goal-text').textContent = formatGoal(data.current_goal || data.currentGoal);
      }
      const targetEl = bubble.querySelector('.goal-target');
      if (data.target_asset || data.targetAsset || data.target) {
        const target = data.target_asset || data.targetAsset || data.target;
        targetEl.textContent = `Target: ${target}`;
        targetEl.style.display = 'block';
      } else {
        targetEl.textContent = '';
        targetEl.style.display = 'none';
      }

      bubble.querySelectorAll('.critic-badge').forEach(b => {
        b.classList.remove('approve', 'reject');
        b.classList.add('pending');
      });
      bubble.querySelector('.decision-section').classList.remove('active');

      // Auto-expand if not already showing another
      if (!state.expandedDroneId) {
        toggleDroneBubble(droneId);
      }

      resetBubbleTimeout(droneId);
    }

    function handleThinkingUpdate(droneId, data) {
      ensureDrone(droneId);
      const drone = state.drones.get(droneId);
      const bubble = drone.bubble;

      if (data.risk_score !== undefined || data.riskScore !== undefined) {
        const score = data.risk_score ?? data.riskScore;
        const level = data.risk_level || data.riskLevel || getRiskLevel(score);
        updateRisk(bubble, score, level);
      }

      if (data.considerations && data.considerations.length > 0) {
        updateReasoning(bubble, data.considerations);
      }

      if (data.current_goal || data.currentGoal) {
        bubble.querySelector('.goal-text').textContent = formatGoal(data.current_goal || data.currentGoal);
      }

      // Update target if provided
      if (data.target_asset || data.targetAsset || data.target) {
        const targetEl = bubble.querySelector('.goal-target');
        const target = data.target_asset || data.targetAsset || data.target;
        targetEl.textContent = `Target: ${target}`;
        targetEl.style.display = 'block';
      }

      resetBubbleTimeout(droneId);
    }

    function handleThinkingComplete(droneId, data) {
      ensureDrone(droneId);
      const drone = state.drones.get(droneId);
      const bubble = drone.bubble;

      updateIndicatorState(droneId, 'predictive', false);

      bubble.classList.remove('deciding');
      bubble.classList.add('complete');

      // Update target if provided in completion
      if (data.target_asset || data.targetAsset || data.target) {
        const targetEl = bubble.querySelector('.goal-target');
        const target = data.target_asset || data.targetAsset || data.target;
        targetEl.textContent = `Target: ${target}`;
        targetEl.style.display = 'block';
      }

      const decisionSection = bubble.querySelector('.decision-section');
      const action = data.decision_action || data.action || 'UNKNOWN';
      const target = data.target_asset || data.targetAsset || data.target;

      // Show action with target if available
      let actionText = action;
      if (target && action !== 'WAIT' && action !== 'HOLD') {
        actionText = `${action} ‚Üí ${target}`;
      }
      decisionSection.querySelector('.decision-action').textContent = actionText;
      decisionSection.querySelector('.decision-icon').textContent = ACTION_ICONS[action] || ACTION_ICONS['default'];
      decisionSection.querySelector('.decision-confidence').textContent = `${((data.decision_confidence || data.confidence || 0) * 100).toFixed(0)}%`;
      decisionSection.querySelector('.decision-reasoning').textContent = data.decision_reasoning || data.reasoning || '';
      decisionSection.classList.add('active');

      resetBubbleTimeout(droneId, 10000);
    }

    function handleCriticResult(droneId, data) {
      ensureDrone(droneId);
      const drone = state.drones.get(droneId);
      const bubble = drone.bubble;

      const criticName = data.critic_name || data.criticName;
      const verdict = data.verdict;

      const badge = bubble.querySelector(`.critic-badge[data-critic="${criticName}"]`);
      if (badge) {
        badge.classList.remove('pending', 'approve', 'reject');
        badge.classList.add(verdict === 'approve' ? 'approve' : 'reject');
      }

      resetBubbleTimeout(droneId);
    }

    function handleRiskUpdate(droneId, data) {
      const drone = state.drones.get(droneId);
      if (!drone) return;

      const score = data.overall_score || data.overallScore || 0;
      const level = data.level || getRiskLevel(score);
      updateRisk(drone.bubble, score, level);
    }

    function ensureDrone(droneId) {
      if (!state.drones.has(droneId)) {
        renderDrone({ drone_id: droneId, latitude: CONFIG.dockLat, longitude: CONFIG.dockLon, altitude_agl: 0 });
      }
    }

    function updateRisk(bubble, score, level) {
      const valueEl = bubble.querySelector('.risk-value');
      const fillEl = bubble.querySelector('.risk-fill');
      const levelLower = level.toLowerCase();
      const percentage = Math.round(score * 100);

      valueEl.textContent = `${percentage}%`;
      valueEl.className = `risk-value ${levelLower}`;
      fillEl.style.width = `${percentage}%`;
      fillEl.className = `risk-fill ${levelLower}`;
    }

    function updateReasoning(bubble, items) {
      const list = bubble.querySelector('.reasoning-list');
      list.innerHTML = '';
      items.slice(0, 4).forEach(item => {
        const li = document.createElement('li');
        li.className = 'reasoning-item';
        li.textContent = item;
        list.appendChild(li);
      });
    }

    function formatGoal(goalType) {
      const goalMap = {
        'INSPECT_ASSET': 'Inspect Asset', 'INSPECT_ANOMALY': 'Inspect Anomaly',
        'RETURN_LOW_BATTERY': 'Return (Low Battery)', 'RETURN_WEATHER': 'Return (Weather)',
        'RETURN_MISSION_COMPLETE': 'Mission Complete', 'ABORT': 'Abort Mission', 'WAIT': 'Waiting'
      };
      return goalMap[goalType] || goalType;
    }

    function getRiskLevel(score) {
      if (score < 0.25) return 'low';
      if (score < 0.5) return 'moderate';
      if (score < 0.75) return 'high';
      return 'critical';
    }

    function resetBubbleTimeout(droneId, duration = CONFIG.thoughtTimeout) {
      const drone = state.drones.get(droneId);
      if (!drone) return;

      if (drone.timeout) clearTimeout(drone.timeout);

      drone.timeout = setTimeout(() => {
        if (state.expandedDroneId === droneId) {
          drone.bubble.classList.remove('visible');
          state.expandedDroneId = null;
        }
        updateIndicatorState(droneId, 'reactive', false);
      }, duration);
    }

    function hideEmptyState() {
      if (!emptyState.classList.contains('hidden')) {
        emptyState.classList.add('hidden');
        sceneInfo.style.display = 'block';
      }
    }

    // ========== CAMERA ==========
    function handleCameraFrame(data) {
      if (!data.image_base64) return;

      const droneId = data.drone_id || cameraState.selectedDroneId || cameraState.droneId || 'Drone1';
      const knownDrone = state.drones.has(droneId);

      // Store frame for this drone
      cameraState.frames.set(droneId, {
        image_base64: data.image_base64,
        timestamp: Date.now()
      });
      cameraState.streamingDrones.add(droneId);

      // Update thumbnail for this drone
      updateCameraThumbnail(droneId, data.image_base64);

      // Auto-select first drone if none selected
      if (!cameraState.selectedDroneId && (knownDrone || state.drones.size === 0)) {
        selectCameraDrone(droneId);
        return;
      }

      // Only display if this is the selected drone
      if (droneId === cameraState.selectedDroneId) {
        displayCameraFrame(droneId, data.image_base64);
      }
    }

    function displayCameraFrame(droneId, imageBase64) {
      if (droneId !== cameraState.droneId) {
        cameraState.droneId = droneId;
        cameraDroneName.textContent = state.drones.get(droneId)?.data?.name || droneId;
      }

      cameraImage.src = `data:image/png;base64,${imageBase64}`;
      cameraImage.style.display = 'block';
      cameraPlaceholder.style.display = 'none';
      cameraOverlay.style.display = 'flex';
      cameraFps.style.display = 'block';

      cameraState.frameCount++;
      const now = performance.now();
      if (now - cameraState.lastFrameTime >= 1000) {
        cameraState.fps = cameraState.frameCount;
        cameraState.frameCount = 0;
        cameraState.lastFrameTime = now;
        cameraFps.textContent = `${cameraState.fps} FPS`;
      }

      if (!cameraState.streaming) {
        cameraState.streaming = true;
        updateCameraUI(true);
      }
    }

    async function selectCameraDrone(droneId) {
      const previousDroneId = cameraState.selectedDroneId;
      cameraState.selectedDroneId = droneId;
      cameraState.droneId = droneId;

      // Update drone name display
      if (!state.drones.has(droneId)) {
        ensureDrone(droneId);
      }
      const droneData = state.drones.get(droneId);
      cameraDroneName.textContent = droneData?.data?.name || droneId;

      // Update tabs UI
      renderDroneCameraTabs();

      // Display cached frame if available (while waiting for new stream)
      const cachedFrame = cameraState.frames.get(droneId);
      if (cachedFrame) {
        displayCameraFrame(droneId, cachedFrame.image_base64);
      }

      // Update target info for the newly selected drone
      updateTargetInfoForDrone(droneId);

      // If streaming is active, start stream for new drone
      if (cameraState.streaming && !cameraState.streamingDrones.has(droneId)) {
        try {
          appendLog(`Starting camera for ${droneId}...`, 'info');
          const response = await fetch(
            `${CONFIG.httpBase}/api/camera/start_stream?drone_id=${encodeURIComponent(droneId)}&fps=15`,
            { method: 'POST' }
          );
          if (response.ok) {
            cameraState.streamingDrones.add(droneId);
            appendLog(`Camera stream started for ${droneId}`, 'success');
          }
        } catch (error) {
          appendLog(`Failed to start camera for ${droneId}: ${error.message}`, 'warning');
        }
      }

      appendLog(`Switched camera to ${droneId}`, 'info');
    }

    function renderDroneCameraTabs() {
      droneCameraTabs.innerHTML = '';

      // Get all known drones
      const droneIds = Array.from(
        new Set([...state.drones.keys(), ...cameraState.availableVehicles])
      );
      if (droneIds.length === 0) return;

      if (!cameraState.selectedDroneId) {
        cameraState.selectedDroneId = droneIds[0];
        cameraState.droneId = droneIds[0];
        const droneData = state.drones.get(droneIds[0]);
        cameraDroneName.textContent = droneData?.data?.name || droneIds[0];
        updateTargetInfoForDrone(droneIds[0]);
      }

      droneIds.forEach(droneId => {
        const droneData = state.drones.get(droneId);
        const isStreaming = cameraState.streamingDrones.has(droneId);
        const isSelected = droneId === cameraState.selectedDroneId;

        const tab = document.createElement('button');
        tab.className = `drone-camera-tab ${isSelected ? 'active' : ''} ${isStreaming ? 'streaming' : ''}`;

        // Show drone name with streaming indicator
        const name = droneData?.data?.name || droneId;
        tab.innerHTML = isStreaming
          ? `<span class="stream-dot"></span>${name}`
          : name;

        tab.onclick = () => selectCameraDrone(droneId);
        droneCameraTabs.appendChild(tab);
      });
    }

    function updateCameraThumbnail(droneId, imageBase64) {
      // Find or create thumbnail for this drone
      let thumb = cameraThumbnails.querySelector(`[data-drone-id="${droneId}"]`);

      if (!thumb) {
        thumb = document.createElement('div');
        thumb.className = 'camera-thumbnail';
        thumb.setAttribute('data-drone-id', droneId);
        thumb.onclick = () => selectCameraDrone(droneId);

        const img = document.createElement('img');
        img.alt = `${droneId} camera`;
        thumb.appendChild(img);

        const label = document.createElement('div');
        label.className = 'thumb-label';
        const droneData = state.drones.get(droneId);
        label.textContent = droneData?.data?.name || droneId;
        thumb.appendChild(label);

        cameraThumbnails.appendChild(thumb);
      }

      // Update thumbnail image
      const img = thumb.querySelector('img');
      if (img) {
        img.src = `data:image/png;base64,${imageBase64}`;
      }

      // Update selected state
      thumb.classList.toggle('selected', droneId === cameraState.selectedDroneId);
    }

    function updateCameraUI(streaming) {
      cameraStartBtn.disabled = streaming;
      cameraStopBtn.disabled = !streaming;
      cameraStreamStatus.textContent = streaming ? 'LIVE' : 'OFF';

      if (!streaming) {
        cameraImage.style.display = 'none';
        cameraPlaceholder.style.display = 'block';
        cameraOverlay.style.display = 'none';
        cameraFps.style.display = 'none';
      }
    }

    cameraStartBtn.addEventListener('click', async () => {
      cameraStartBtn.disabled = true;
      try {
        const preferredDroneId = cameraState.selectedDroneId || cameraState.droneId;
        if (!preferredDroneId) {
          throw new Error('No drone available for streaming');
        }
        const response = await fetch(`${CONFIG.httpBase}/api/camera/start_stream?drone_id=${encodeURIComponent(preferredDroneId)}&fps=15`, { method: 'POST' });
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        cameraState.streaming = true;
        updateCameraUI(true);
        appendLog(`Camera started for ${preferredDroneId}`, 'info');
      } catch (error) {
        cameraStartBtn.disabled = false;
        appendLog(`Camera error: ${error.message}`, 'error');
      }
    });

    cameraStopBtn.addEventListener('click', async () => {
      cameraStopBtn.disabled = true;
      try {
        const preferredDroneId = cameraState.selectedDroneId || cameraState.droneId;
        if (!preferredDroneId) {
          throw new Error('No drone available for streaming');
        }
        await fetch(`${CONFIG.httpBase}/api/camera/stop_stream?drone_id=${encodeURIComponent(preferredDroneId)}`, { method: 'POST' });
        cameraState.streaming = false;
        updateCameraUI(false);
        appendLog('Camera stopped', 'info');
      } catch (error) {
        cameraStopBtn.disabled = false;
        appendLog(`Camera stop error: ${error.message}`, 'error');
      }
    });

    async function refreshCameraStatus() {
      try {
        const resp = await fetch(`${CONFIG.httpBase}/api/camera/status`);
        if (!resp.ok) return;
        const data = await resp.json();
        const available = Array.isArray(data.available_vehicles) ? data.available_vehicles : [];
        const active = Array.isArray(data.active_streams) ? data.active_streams : [];

        cameraState.availableVehicles = new Set(available);
        cameraState.streamingDrones = new Set(active);

        if (!cameraState.selectedDroneId && available.length > 0) {
          cameraState.selectedDroneId = available[0];
          cameraState.droneId = available[0];
          cameraDroneName.textContent = available[0];
        }

        renderDroneCameraTabs();
      } catch (error) {
        // Ignore camera status polling failures.
      }
    }

    // ========== DEBUG FLIGHT CONTROLS ==========
    const debugStatus = document.getElementById('debugStatus');
    const debugTakeoff = document.getElementById('debugTakeoff');
    const debugLand = document.getElementById('debugLand');
    const debugRTL = document.getElementById('debugRTL');
    const debugGoTarget = document.getElementById('debugGoTarget');
    const debugReset = document.getElementById('debugReset');

    console.log('Debug controls loaded:', { debugTakeoff, debugLand, debugRTL, debugGoTarget, debugReset });

    async function debugFlightAction(action, endpoint, params = {}) {
      console.log(`debugFlightAction: ${action} -> ${endpoint}`, params);
      if (debugStatus) debugStatus.textContent = `${action}...`;
      appendLog(`Debug: ${action}`, 'info');
      try {
        const url = new URL(`${CONFIG.httpBase}${endpoint}`);
        Object.entries(params).forEach(([k, v]) => url.searchParams.set(k, v));
        console.log('Fetching:', url.toString());
        const response = await fetch(url.toString(), { method: 'POST' });
        const payload = await response.json();
        console.log('Response:', payload);
        if (!response.ok) throw new Error(payload.detail || `HTTP ${response.status}`);
        if (debugStatus) debugStatus.textContent = `${action}: ${payload.status || 'OK'}`;
        appendLog(`Debug ${action}: ${payload.status || 'completed'}`, 'success');
        return payload;
      } catch (error) {
        console.error('debugFlightAction error:', error);
        if (debugStatus) debugStatus.textContent = `${action} failed`;
        appendLog(`Debug ${action} error: ${error.message}`, 'error');
        return null;
      }
    }

    if (debugTakeoff) {
      debugTakeoff.addEventListener('click', () => {
        console.log('Takeoff button clicked');
        debugFlightAction('Takeoff', '/api/airsim/flight/takeoff', { altitude: 30 });
      });
    } else {
      console.warn('debugTakeoff button not found');
    }

    if (debugLand) {
      debugLand.addEventListener('click', () => {
        console.log('Land button clicked');
        debugFlightAction('Land', '/api/airsim/flight/land');
      });
    }

    if (debugRTL) {
      debugRTL.addEventListener('click', () => {
        console.log('RTL button clicked');
        debugFlightAction('Return to Dock', '/api/airsim/flight/rtl');
      });
    }

    if (debugGoTarget) {
      debugGoTarget.addEventListener('click', () => {
        console.log('Go to Target button clicked');
        // If we have assets, fly to the first one; otherwise fly to a default position
        const firstAsset = state.assets.size > 0 ? Array.from(state.assets.values())[0] : null;
        if (firstAsset && firstAsset.data) {
          const local = gpsToLocal(firstAsset.data.latitude, firstAsset.data.longitude);
          debugFlightAction('Go to Target', '/api/airsim/debug_fly_to', {
            north: local.x.toFixed(1),
            east: local.y.toFixed(1),
            down: -30  // 30m altitude
          });
        } else {
          // Default: fly forward and right
          debugFlightAction('Go to Target', '/api/airsim/debug_fly_to', {
            north: 50,
            east: 50,
            down: -30
          });
        }
      });
    }

    if (debugReset) {
      debugReset.addEventListener('click', () => {
        console.log('Reset button clicked');
        debugFlightAction('Reset', '/api/airsim/reset', { altitude: 5 });
      });
    }

    const debugPosition = document.getElementById('debugPosition');
    const debugAltitude = document.getElementById('debugAltitude');

    function updateDebugTelemetry(lat, lon, alt) {
      if (debugPosition) {
        debugPosition.textContent = `${lat.toFixed(5)}, ${lon.toFixed(5)}`;
      }
      if (debugAltitude) {
        debugAltitude.textContent = `${alt.toFixed(1)} m`;
      }
    }

    // ========== SCENARIO CONTROLS ==========
    async function loadScenarios() {
      scenarioSelect.innerHTML = '<option value="">Loading...</option>';
      try {
        const response = await fetch(`${CONFIG.httpBase}/api/scenarios`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const payload = await response.json();
        const scenarios = payload.scenarios || [];
        if (!scenarios.length) {
          scenarioSelect.innerHTML = '<option value="">No scenarios</option>';
          return;
        }
        scenarioSelect.innerHTML = '';
        scenarios.forEach(s => {
          const opt = document.createElement('option');
          opt.value = s.scenario_id;
          opt.textContent = `${s.scenario_id} - ${s.name}`;
          scenarioSelect.appendChild(opt);
        });
      } catch (error) {
        scenarioSelect.innerHTML = '<option value="">Load failed</option>';
      }
    }

    async function refreshScenarioStatus() {
      try {
        const response = await fetch(`${CONFIG.httpBase}/api/scenarios/status`);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        const payload = await response.json();
        if (!payload.running) {
          scenarioStatus.textContent = 'Idle';
          // If we had a scenario loaded but it's no longer running, clear it
          if (state.scenario) {
            state.scenarioIdleCount += 1;
            if (state.scenarioIdleCount >= 3) {
              state.scenarioIdleCount = 0;
              state.scenario = null;
              clearScene();
              renderGrid();
              renderDock();
              emptyState.classList.remove('hidden');
              sceneInfo.style.display = 'none';
            }
          }
          return;
        }
        state.scenarioIdleCount = 0;
        scenarioStatus.textContent = `Running: ${payload.scenario_id}`;
        document.getElementById('infoScenario').textContent = payload.scenario_id;

        // If scenario is running but not yet loaded (e.g., after page refresh), load it
        if (!state.scenario || state.scenario.scenario_id !== payload.scenario_id) {
          console.log('Loading running scenario:', payload.scenario_id);
          await loadScenarioScene(payload.scenario_id);
        }
      } catch (error) {
        console.error('Status error:', error);
      }
    }

    scenarioStart.addEventListener('click', async () => {
      const scenarioId = scenarioSelect.value;
      if (!scenarioId) {
        appendLog('Select a scenario first', 'warning');
        return;
      }
      scenarioStatus.textContent = 'Starting...';
      appendLog(`Starting: ${scenarioId}`, 'info');
      try {
        const response = await fetch(`${CONFIG.httpBase}/api/scenarios/${scenarioId}/start`, { method: 'POST' });
        const contentType = response.headers.get('content-type') || '';

        // Handle non-JSON responses (server errors, etc.)
        if (!contentType.includes('application/json')) {
          const text = await response.text();
          console.error('Non-JSON response:', response.status, text.slice(0, 500));
          throw new Error(`Server error: HTTP ${response.status}`);
        }

        // Read response text first to handle empty responses
        const text = await response.text();
        if (!text || text.trim() === '') {
          console.error('Empty response body from server');
          throw new Error(`Server returned empty response (HTTP ${response.status})`);
        }

        let payload;
        try {
          payload = JSON.parse(text);
        } catch (parseError) {
          console.error('JSON parse error:', parseError, 'Response text:', text.slice(0, 200));
          throw new Error(`Invalid JSON response: ${text.slice(0, 100)}`);
        }
        if (!response.ok) throw new Error(payload.detail || `HTTP ${response.status}`);

        scenarioStatus.textContent = `Running: ${payload.scenario_id}`;
        document.getElementById('infoScenario').textContent = payload.scenario_id;
        appendLog(`Started: ${payload.scenario_id}`, 'success');

        // Fetch and render scenario details
        await loadScenarioScene(scenarioId);
      } catch (error) {
        scenarioStatus.textContent = 'Start failed';
        appendLog(`Start failed: ${error.message}`, 'error');
        console.error('Scenario start error:', error);
      }
    });

    scenarioStop.addEventListener('click', async () => {
      scenarioStatus.textContent = 'Stopping...';
      appendLog('Stopping scenario...', 'info');
      try {
        const response = await fetch(`${CONFIG.httpBase}/api/scenarios/stop`, { method: 'POST' });
        const text = await response.text();
        let payload = {};
        if (text && text.trim()) {
          try {
            payload = JSON.parse(text);
          } catch (e) {
            console.error('Stop response parse error:', e, text.slice(0, 200));
          }
        }
        if (!response.ok) throw new Error(payload.detail || `HTTP ${response.status}`);

        scenarioStatus.textContent = 'Idle';
        appendLog('Scenario stopped', 'success');
        clearScene();
        renderGrid();
        renderDock();
        emptyState.classList.remove('hidden');
        sceneInfo.style.display = 'none';
      } catch (error) {
        scenarioStatus.textContent = 'Stop failed';
        appendLog(`Stop failed: ${error.message}`, 'error');
      }
    });

    async function loadScenarioScene(scenarioId) {
      try {
        const response = await fetch(`${CONFIG.httpBase}/api/scenarios/${scenarioId}`);
        if (!response.ok) return;
        const scenario = await response.json();

        clearScene();
        renderGrid();
        renderDock();

        // Render assets
        if (scenario.assets) {
          scenario.assets.forEach(asset => renderAsset(asset));
          document.getElementById('infoAssets').textContent = scenario.assets.length;
        }

        // Render drones
        if (scenario.drones) {
          scenario.drones.forEach(drone => renderDrone(drone));
          document.getElementById('infoDrones').textContent = scenario.drones.length;
        }

        state.scenario = scenario;
        hideEmptyState();

        // Set target from scenario assets
        setTargetFromScenario(scenario);

        // Fetch SLAM data and map preview
        await refreshMapPreview();
        await refreshSlamData();
      } catch (error) {
        console.error('Failed to load scenario scene:', error);
      }
    }

    async function refreshMapPreview() {
      try {
        const [previewResp, statusResp] = await Promise.all([
          fetch(`${CONFIG.httpBase}/api/navigation/map/preview`),
          fetch(`${CONFIG.httpBase}/api/navigation/map/status`)
        ]);
        if (!previewResp.ok) return;
        const payload = await previewResp.json();
        if (!payload.preview) return;
        state.mapPreview = payload.preview;
        if (statusResp.ok) {
          state.mapStatus = await statusResp.json();
        }

        // Extract obstacles for SLAM overlay - render in main view
        if (payload.preview.obstacles && payload.preview.obstacles.length > 0) {
          state.slamObstacles = payload.preview.obstacles;
          renderSlamObstacles();
        }

        if (payload.preview.points && payload.preview.points.length > 0) {
          state.previewPoints = payload.preview.points;
          if (state.splatPoints.length === 0) {
            renderSplatPoints();
          }
        } else if (state.previewPoints.length > 0 && state.splatPoints.length === 0) {
          state.previewPoints = [];
          renderSplatPoints();
        }

        maybeAutoFit();

        // Note: Map cube preview removed - obstacles now render in main coordinate space
      } catch (error) {
        console.error('Failed to load map preview:', error);
      }
    }

    async function refreshSlamData() {
      try {
        // Fetch splat scenes
        const scenesResp = await fetch(`${CONFIG.httpBase}/api/navigation/splat/scenes`);
        if (scenesResp.ok) {
          const scenesData = await scenesResp.json();
          const scenes = scenesData.scenes || [];

          // If we have scenes and not currently loading, fetch first scene preview
          if (scenes.length > 0 && !state.splatLoading) {
            state.splatLoading = true;
            const firstScene = scenes[0];

            try {
              const previewResp = await fetch(`${CONFIG.httpBase}/api/navigation/splat/preview/${firstScene.run_id}`);
              if (previewResp.ok) {
                const previewData = await previewResp.json();
                state.splatPoints = previewData.points || [];
                renderSplatPoints();
              }
            } catch (e) {
              console.warn('Failed to load splat preview:', e);
            }

            state.splatLoading = false;
          }
        }

        // Also fetch latest navigation map for obstacles
        const mapResp = await fetch(`${CONFIG.httpBase}/api/navigation/map/latest`);
        if (mapResp.ok) {
          const mapData = await mapResp.json();
          if (mapData.obstacles && mapData.obstacles.length > 0) {
            state.slamObstacles = mapData.obstacles;
          }

          const metadata = mapData.metadata || {};
          const originLat = metadata.origin_latitude;
          const originLon = metadata.origin_longitude;
          const dockChanged = (originLat != null && originLon != null)
            ? setDockReference(originLat, originLon, 'map_metadata')
            : false;

          if (!dockChanged && state.slamObstacles && state.slamObstacles.length > 0) {
            renderSlamObstacles();
          }
        }

        maybeAutoFit();
      } catch (error) {
        console.warn('Failed to refresh SLAM data:', error);
      }
    }

    function setupZoomButtons() {
      const zoomIn = document.getElementById('zoomIn');
      const zoomOut = document.getElementById('zoomOut');
      const resetView = document.getElementById('resetView');
      const fitView = document.getElementById('fitView');

      if (zoomIn) {
        zoomIn.addEventListener('click', () => {
          CONFIG.zoom = Math.min(CONFIG.maxZoom, CONFIG.zoom * 1.2);
          state.autoFitEnabled = false;
          updateAutoFitIndicator();
          redrawScene();
          updateZoomIndicator();
        });
      }

      if (zoomOut) {
        zoomOut.addEventListener('click', () => {
          CONFIG.zoom = Math.max(CONFIG.minZoom, CONFIG.zoom * 0.8);
          state.autoFitEnabled = false;
          updateAutoFitIndicator();
          redrawScene();
          updateZoomIndicator();
        });
      }

      if (resetView) {
        resetView.addEventListener('click', () => {
          resetCameraState();
        });
      }

      if (fitView) {
        fitView.addEventListener('click', () => {
          fitToMapView();
        });
      }

      const autoFitToggle = document.getElementById('autoFitToggle');
      if (autoFitToggle) {
        autoFitToggle.addEventListener('click', () => {
          toggleAutoFit();
        });
      }
    }

    function setTargetFromScenario(scenario) {
      if (!scenario || !scenario.assets || scenario.assets.length === 0) {
        state.target = null;
        renderTarget();
        return;
      }

      // Find the first asset with an anomaly, or the first asset
      let targetAsset = scenario.assets.find(a => a.has_anomaly) || scenario.assets[0];

      if (targetAsset) {
        const local = gpsToLocal(targetAsset.latitude, targetAsset.longitude);
        state.target = {
          x: local.x,
          y: local.y,
          z: targetAsset.altitude_m || 10,
          lat: targetAsset.latitude,
          lon: targetAsset.longitude,
          name: targetAsset.name || 'Target',
          assetId: targetAsset.asset_id
        };
        renderTarget();
        appendLog(`Target: ${state.target.name}`, 'info');
      }
    }

    // ========== LOGGING ==========
    const LOG_LIMIT = 8;

    function appendLog(message, level = 'info') {
      if (!scenarioLogList) return;
      scenarioLogEmpty.style.display = 'none';

      const entry = document.createElement('div');
      entry.className = `log-entry ${level}`;
      entry.innerHTML = `
        <div class="meta">
          <span>${new Date().toLocaleTimeString()}</span>
          <span class="level">${level.toUpperCase()}</span>
        </div>
        <div class="message">${message}</div>
      `;

      scenarioLogList.prepend(entry);
      while (scenarioLogList.children.length > LOG_LIMIT + 1) {
        scenarioLogList.removeChild(scenarioLogList.lastElementChild);
      }
    }

    // ========== SIDEBAR TOGGLES ==========
    document.querySelectorAll('.section-header').forEach(header => {
      header.addEventListener('click', () => {
        const section = header.dataset.section;
        const content = document.getElementById(`${section}Section`);
        const toggle = header.querySelector('.section-toggle');
        if (content.classList.contains('collapsed')) {
          content.classList.remove('collapsed');
          toggle.textContent = '-';
        } else {
          content.classList.add('collapsed');
          toggle.textContent = '+';
        }
      });
    });

    // ========== SLAM CONFIG CONTROLS ==========
    function initSlamConfigControls() {
      // Toggle controls
      const toggles = document.querySelectorAll('.slam-toggle');
      toggles.forEach(toggle => {
        toggle.addEventListener('click', () => {
          const key = toggle.dataset.key;
          if (key && slamConfig.hasOwnProperty(key)) {
            slamConfig[key] = !slamConfig[key];
            toggle.classList.toggle('active', slamConfig[key]);
            // Re-render SLAM visualization
            renderSlamObstacles();
            renderSplatPoints();
          }
        });
      });

      // Height Max slider
      const heightMaxSlider = document.getElementById('slamHeightMax');
      const heightMaxValue = document.getElementById('slamHeightMaxValue');
      if (heightMaxSlider) {
        heightMaxSlider.addEventListener('input', () => {
          slamConfig.heightMax = parseInt(heightMaxSlider.value, 10);
          heightMaxValue.textContent = `${slamConfig.heightMax}m`;
          renderSlamObstacles();
          renderSplatPoints();
        });
      }

      // Height Min slider
      const heightMinSlider = document.getElementById('slamHeightMin');
      const heightMinValue = document.getElementById('slamHeightMinValue');
      if (heightMinSlider) {
        heightMinSlider.addEventListener('input', () => {
          slamConfig.heightMin = parseInt(heightMinSlider.value, 10);
          heightMinValue.textContent = `${slamConfig.heightMin}m`;
          renderSlamObstacles();
          renderSplatPoints();
        });
      }

      // Point Size slider
      const pointSizeSlider = document.getElementById('slamPointSize');
      const pointSizeValue = document.getElementById('slamPointSizeValue');
      if (pointSizeSlider) {
        pointSizeSlider.addEventListener('input', () => {
          slamConfig.pointSize = parseInt(pointSizeSlider.value, 10);
          pointSizeValue.textContent = String(slamConfig.pointSize);
          renderSplatPoints();
        });
      }

      // Opacity slider
      const opacitySlider = document.getElementById('slamOpacity');
      const opacityValue = document.getElementById('slamOpacityValue');
      if (opacitySlider) {
        opacitySlider.addEventListener('input', () => {
          slamConfig.opacity = parseInt(opacitySlider.value, 10) / 100;
          opacityValue.textContent = `${opacitySlider.value}%`;
          renderSlamObstacles();
          renderSplatPoints();
        });
      }

      // Offset X slider (East/West)
      const offsetXSlider = document.getElementById('slamOffsetX');
      const offsetXValue = document.getElementById('slamOffsetXValue');
      if (offsetXSlider) {
        offsetXSlider.addEventListener('input', () => {
          slamConfig.offsetX = parseInt(offsetXSlider.value, 10);
          offsetXValue.textContent = `${slamConfig.offsetX}m`;
          renderSlamObstacles();
          renderSplatPoints();
        });
      }

      // Offset Y slider (North/South)
      const offsetYSlider = document.getElementById('slamOffsetY');
      const offsetYValue = document.getElementById('slamOffsetYValue');
      if (offsetYSlider) {
        offsetYSlider.addEventListener('input', () => {
          slamConfig.offsetY = parseInt(offsetYSlider.value, 10);
          offsetYValue.textContent = `${slamConfig.offsetY}m`;
          renderSlamObstacles();
          renderSplatPoints();
        });
      }

      // View Tilt slider
      const viewAngleSlider = document.getElementById('slamViewAngle');
      const viewAngleValue = document.getElementById('slamViewAngleValue');
      if (viewAngleSlider) {
        viewAngleSlider.addEventListener('input', () => {
          slamConfig.viewAngle = parseInt(viewAngleSlider.value, 10);
          viewAngleValue.textContent = `${slamConfig.viewAngle}¬∞`;
          rerenderEntireSceneThrottled();
        });
      }

      // Rotation slider
      const rotationSlider = document.getElementById('slamRotation');
      const rotationValue = document.getElementById('slamRotationValue');
      if (rotationSlider) {
        rotationSlider.addEventListener('input', () => {
          slamConfig.rotationAngle = parseInt(rotationSlider.value, 10);
          rotationValue.textContent = `${slamConfig.rotationAngle}¬∞`;
          rerenderEntireSceneThrottled();
        });
      }
    }

    // Throttled re-render to prevent UI lockup during slider drag
    let rerenderRAF = null;
    function rerenderEntireSceneThrottled() {
      if (rerenderRAF) return;
      rerenderRAF = requestAnimationFrame(() => {
        rerenderEntireScene();
        rerenderRAF = null;
      });
    }

    // Re-render entire scene when view angle changes
    function rerenderEntireScene() {
      // Re-render grid
      renderGrid();
      // Re-render dock
      renderDock();
      // Re-render assets
      state.assets.forEach((assetData, assetId) => {
        if (assetData.element) assetData.element.remove();
        renderAsset(assetData.data);
      });
      // Re-render drones at their current positions
      state.drones.forEach((droneData, droneId) => {
        if (droneData.element) {
          const lat = droneData.data.latitude ?? droneData.data.position?.latitude ?? CONFIG.dockLat;
          const lon = droneData.data.longitude ?? droneData.data.position?.longitude ?? CONFIG.dockLon;
          const alt = droneData.data.altitude_agl ?? droneData.data.position?.altitude_agl ?? 0;
          updateDroneVisualPosition(droneId, lat, lon, alt);
        }
      });
      // Re-render SLAM data (pass state data to functions that need it)
      renderMapCube(state.mapPreview, state.mapStatus);
      renderSlamObstacles();
      renderSplatPoints();
      renderTarget();
    }

    // Initialize SLAM config controls
    initSlamConfigControls();

    // ========== AIRSIM CONTROLS ==========
    const airsimStatusValue = document.getElementById('airsimStatusValue');
    const airsimLaunchBtn = document.getElementById('airsimLaunchBtn');
    const airsimReconnectBtn = document.getElementById('airsimReconnectBtn');
    const airsimResetDroneBtn = document.getElementById('airsimResetDroneBtn');
    const airsimForceCloseBtn = document.getElementById('airsimForceCloseBtn');
    const refreshOverlayBtn = document.getElementById('refreshOverlayBtn');
    const syncSceneBtn = document.getElementById('syncSceneBtn');

    async function refreshAirsimStatus() {
      try {
        const resp = await fetch(`${CONFIG.httpBase}/api/airsim/status`);
        if (resp.ok) {
          const data = await resp.json();
          const connected = data.bridge_connected;
          airsimStatusValue.textContent = connected ? 'Connected' : 'Disconnected';
          airsimStatusValue.className = `airsim-status-value ${connected ? 'connected' : 'disconnected'}`;
        }
      } catch (e) {
        airsimStatusValue.textContent = 'Error';
        airsimStatusValue.className = 'airsim-status-value disconnected';
      }
    }

    // Launch AirSim
    airsimLaunchBtn?.addEventListener('click', async () => {
      airsimLaunchBtn.disabled = true;
      airsimLaunchBtn.textContent = 'Launching...';
      try {
        const resp = await fetch(`${CONFIG.httpBase}/api/airsim/start`, { method: 'POST' });
        const data = await resp.json();
        appendLog(`AirSim: ${data.launch_message || 'Launch initiated'}`, data.launch_started ? 'info' : 'warning');
        // Wait a bit then check status
        setTimeout(refreshAirsimStatus, 3000);
      } catch (e) {
        appendLog(`AirSim launch error: ${e.message}`, 'error');
      } finally {
        airsimLaunchBtn.disabled = false;
        airsimLaunchBtn.textContent = 'Launch';
      }
    });

    // Reconnect to AirSim
    airsimReconnectBtn?.addEventListener('click', async () => {
      airsimReconnectBtn.disabled = true;
      airsimReconnectBtn.textContent = 'Connecting...';
      airsimStatusValue.textContent = 'Connecting...';
      airsimStatusValue.className = 'airsim-status-value connecting';
      try {
        const resp = await fetch(`${CONFIG.httpBase}/api/airsim/reconnect`, { method: 'POST' });
        const data = await resp.json();
        appendLog(`AirSim reconnect: ${data.status || 'attempted'}`, data.connected ? 'info' : 'warning');
        await refreshAirsimStatus();
      } catch (e) {
        appendLog(`AirSim reconnect error: ${e.message}`, 'error');
        airsimStatusValue.textContent = 'Error';
        airsimStatusValue.className = 'airsim-status-value disconnected';
      } finally {
        airsimReconnectBtn.disabled = false;
        airsimReconnectBtn.textContent = 'Reconnect';
      }
    });

    // Reset drone position
    airsimResetDroneBtn?.addEventListener('click', async () => {
      airsimResetDroneBtn.disabled = true;
      airsimResetDroneBtn.textContent = 'Resetting...';
      try {
        const resp = await fetch(`${CONFIG.httpBase}/api/airsim/reset?altitude=5`, { method: 'POST' });
        const data = await resp.json();
        appendLog(`Drone reset: ${data.message || data.status}`, data.status === 'success' ? 'info' : 'warning');
      } catch (e) {
        appendLog(`Drone reset error: ${e.message}`, 'error');
      } finally {
        airsimResetDroneBtn.disabled = false;
        airsimResetDroneBtn.textContent = 'Reset Drone';
      }
    });

    // Force close AirSim (taskkill)
    airsimForceCloseBtn?.addEventListener('click', async () => {
      if (!confirm('Force close AirSim? This will terminate the Blocks.exe process.')) return;
      airsimForceCloseBtn.disabled = true;
      airsimForceCloseBtn.textContent = 'Closing...';
      try {
        // Try to call a force close endpoint, or use a generic approach
        const resp = await fetch(`${CONFIG.httpBase}/api/airsim/force_close`, { method: 'POST' });
        if (resp.ok) {
          const data = await resp.json();
          appendLog(`AirSim force close: ${data.message || 'sent'}`, 'warning');
        } else {
          // Endpoint might not exist, inform user
          appendLog('Force close: Use Task Manager to close Blocks.exe', 'warning');
        }
        setTimeout(refreshAirsimStatus, 2000);
      } catch (e) {
        appendLog('Force close: Use Task Manager to close Blocks.exe', 'warning');
      } finally {
        airsimForceCloseBtn.disabled = false;
        airsimForceCloseBtn.textContent = 'Force Close';
      }
    });

    // Refresh overlay UI
    refreshOverlayBtn?.addEventListener('click', () => {
      appendLog('Refreshing overlay...', 'info');
      // Close existing WebSocket
      if (state.socket) {
        state.socket.close();
      }
      // Clear state and reconnect
      resetCameraState();
      handleScenarioReset();
      setTimeout(() => {
        connect();
        refreshScenarioStatus();
        refreshAirsimStatus();
        refreshCameraStatus();
      }, 500);
    });

    // Sync scene to AirSim
    syncSceneBtn?.addEventListener('click', async () => {
      syncSceneBtn.disabled = true;
      syncSceneBtn.textContent = 'Syncing...';
      try {
        const resp = await fetch(`${CONFIG.httpBase}/api/airsim/scene/sync`, { method: 'POST' });
        const data = await resp.json();
        appendLog(`Scene sync: ${data.message || data.status || 'completed'}`, 'info');
      } catch (e) {
        appendLog(`Scene sync error: ${e.message}`, 'error');
      } finally {
        syncSceneBtn.disabled = false;
        syncSceneBtn.textContent = 'Sync Scene';
      }
    });

    // Poll AirSim status periodically
    setInterval(refreshAirsimStatus, 10000);
    setInterval(refreshCameraStatus, 10000);

    // ========== WEBSOCKET ==========
    function connect() {
      updateStatus('connecting');
      try {
        state.socket = new WebSocket(CONFIG.serverUrl);

        state.socket.onopen = () => {
          state.connected = true;
          updateStatus('connected');
          state.socket.send(JSON.stringify({ subscribe: [] }));
          // Refresh scenario status on reconnect to sync drones/assets
          refreshScenarioStatus();
          refreshCameraStatus();
        };

        state.socket.onclose = () => {
          state.connected = false;
          updateStatus('disconnected');
          setTimeout(connect, CONFIG.reconnectDelay);
        };

        state.socket.onerror = (error) => console.error('WebSocket error:', error);

        state.socket.onmessage = (event) => {
          try {
            const data = JSON.parse(event.data);
            // Log incoming message types for debugging
            if (data.type && data.type !== 'heartbeat' && data.type !== 'sync') {
              console.log('WS received:', data.type, data.drone_id || '');
            }
            handleMessage(data);
          } catch (e) {
            console.error('Parse error:', e);
          }
        };
      } catch (e) {
        updateStatus('disconnected');
        setTimeout(connect, CONFIG.reconnectDelay);
      }
    }

    function updateStatus(status) {
      statusEl.className = `connection-status ${status}`;
      statusEl.textContent = status === 'connected' ? 'Live' : status === 'connecting' ? 'Connecting' : 'Offline';
    }

    // ========== INIT ==========
    function init() {
      updateOrigin();
      renderGrid();
      renderDock();
      loadScenarios();
      refreshScenarioStatus();
      refreshMapPreview();
      refreshSlamData();
      refreshAirsimStatus();
      setInterval(refreshScenarioStatus, 5000);
      setInterval(refreshMapPreview, 6000);
      setInterval(refreshSlamData, 10000);
      connect();

      // Setup pan/zoom controls
      setupPanZoom();
      setupZoomButtons();

      // Handle resize
      window.addEventListener('resize', () => {
        updateOrigin();
        redrawScene();
      });

      // Transparent mode
      const params = new URLSearchParams(window.location.search);
      if (params.get('transparent') === '1' || params.get('transparent') === 'true') {
        document.body.classList.add('transparent');
      }
    }

    // Debug helper
    window.simulateThinking = function(droneId = 'Drone1') {
      if (!state.drones.has(droneId)) {
        renderDrone({ drone_id: droneId, latitude: CONFIG.dockLat + 0.0003, longitude: CONFIG.dockLon + 0.0002, altitude_agl: 25 });
      }
      hideEmptyState();

      handleThinkingStart(droneId, { cognitive_level: 'deliberative', current_goal: 'INSPECT_ASSET', target_asset: 'solar_panel_007' });
      setTimeout(() => handleThinkingUpdate(droneId, { risk_score: 0.25, risk_level: 'low', considerations: ['Battery at 72%', 'Wind 8kts NW', 'Asset overdue'] }), 1000);
      setTimeout(() => handleCriticResult(droneId, { critic_name: 'safety', verdict: 'approve' }), 2000);
      setTimeout(() => handleCriticResult(droneId, { critic_name: 'efficiency', verdict: 'approve' }), 2500);
      setTimeout(() => handleCriticResult(droneId, { critic_name: 'goal_alignment', verdict: 'approve' }), 3000);
      setTimeout(() => handleThinkingComplete(droneId, { action: 'INSPECT', target_asset: 'solar_panel_007', confidence: 0.92, reasoning: 'High-priority inspection with favorable conditions' }), 3500);
    };

    // Debug helper: test flight control APIs directly
    window.testTakeoff = async function() {
      console.log('Testing takeoff API...');
      try {
        const resp = await fetch(`${CONFIG.httpBase}/api/airsim/flight/takeoff?altitude=30`, { method: 'POST' });
        const data = await resp.json();
        console.log('Takeoff result:', data);
        return data;
      } catch (e) {
        console.error('Takeoff error:', e);
        return null;
      }
    };

    window.testLand = async function() {
      console.log('Testing land API...');
      try {
        const resp = await fetch(`${CONFIG.httpBase}/api/airsim/flight/land`, { method: 'POST' });
        const data = await resp.json();
        console.log('Land result:', data);
        return data;
      } catch (e) {
        console.error('Land error:', e);
        return null;
      }
    };

    window.testRTL = async function() {
      console.log('Testing RTL API...');
      try {
        const resp = await fetch(`${CONFIG.httpBase}/api/airsim/flight/rtl`, { method: 'POST' });
        const data = await resp.json();
        console.log('RTL result:', data);
        return data;
      } catch (e) {
        console.error('RTL error:', e);
        return null;
      }
    };

    window.testReset = async function() {
      console.log('Testing reset API...');
      try {
        const resp = await fetch(`${CONFIG.httpBase}/api/airsim/reset?altitude=5`, { method: 'POST' });
        const data = await resp.json();
        console.log('Reset result:', data);
        return data;
      } catch (e) {
        console.error('Reset error:', e);
        return null;
      }
    };

    window.simulateAssets = function() {
      hideEmptyState();
      renderAsset({ asset_id: 'solar_001', name: 'Solar Farm Alpha', asset_type: 'solar_panel', latitude: CONFIG.dockLat + 0.0005, longitude: CONFIG.dockLon + 0.0003, altitude_m: 5, has_anomaly: false });
      renderAsset({ asset_id: 'solar_002', name: 'Solar Farm Beta', asset_type: 'solar_panel', latitude: CONFIG.dockLat + 0.0002, longitude: CONFIG.dockLon - 0.0004, altitude_m: 5, has_anomaly: true });
      renderAsset({ asset_id: 'sub_001', name: 'Substation One', asset_type: 'substation', latitude: CONFIG.dockLat - 0.0004, longitude: CONFIG.dockLon + 0.0002, altitude_m: 10, has_anomaly: false });
      document.getElementById('infoAssets').textContent = '3';
    };

    init();
    console.log('AegisAV Overlay loaded.');
    console.log('Debug commands: testTakeoff(), testLand(), testRTL(), testReset()');
    console.log('Simulation: simulateThinking(), simulateAssets()');
  </script>
</body>

</html>
